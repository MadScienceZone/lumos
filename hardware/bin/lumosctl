#!/usr/bin/env python3
#
# LUMOS Device Control Script
# For Lumos Hardware Project revision @@RELEASE@@
#
# Copyright (c) 2010, 2011, 2012, 2013, 2022 by Steven L. Willoughby, Aloha,
# Oregon, USA.  All Rights Reserved.  Licensed under the Open Software
# License version 3.0.
#
# This product is provided for educational, experimental or personal
# interest use, in accordance with the terms and conditions of the
# aforementioned license agreement, ON AN "AS IS" BASIS AND WITHOUT
# WARRANTY, EITHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION,
# THE WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A
# PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY OF THE ORIGINAL
# WORK IS WITH YOU.  (See the license agreement for full details, 
# including disclaimer of warranty and limitation of liability.)
#
# Under no curcumstances is this product intended to be used where the
# safety of any person, animal, or property depends upon, or is at
# risk of any kind from, the correct operation of this software or
# the hardware devices which it controls.
#
# USE THIS PRODUCT AT YOUR OWN RISK.
#
# Directly control a Lumos ssr controller via the command line.
# This is primarily intended for configuring and testing a controller
# unit.  For running an actual show, use an application such as Lumos
# (see http://lumos.sourceforge.net).
#
# Requires: Python 3
#           Lumos
#
import optparse
import sys
from   Lumos.ControlAPI import ControlAPI

def parse_arguments():
    parser = optparse.OptionParser(usage='%prog [-dFhikPRrvXz] [-A ADDR] [-a ADDR] [-B SPD] [-b SPD] [-C FILE] [-c FILE] [-D LIST] [-E LIST] [-K HEX] [-L LVL] [-m mS] [-P PH] [-p PORT] [-q BYTES] [-s FILE] [-T MODE] [-x DPX] [-Z SEC] [channel-levels...]', version='%prog, version 1.0')
    parser.add_option('-a', '--address',        metavar='ADDR', type='int', help='Unit address (0-15) [%default]')
#    parser.add_option('-S', '--clear-sequences', action='store_true', help='Delete all stored sequences from the device.')
#    parser.add_option('-D', '--disable-sensor',  metavar='LIST', help='Disable sensor(s) ABCD in LIST')
    parser.add_option('-d', '--drop-configuration-mode', action='store_true', help='Run in normal mode')
    parser.add_option('-C', '--dump-configuration-file', metavar='FILE', help='Get and save device configuration')
    parser.add_option('-x', '--duplex', metavar='DPX', action='store', choices=['full', 'half'], help='Serial duplex mode [%default]')
#    parser.add_option('-E', '--enable-sensor', metavar='LIST', help='Enable sensor(s) ABCD in LIST')
    parser.add_option('-F', '--factory-reset', action='store_true', help='Reset to factory default settings')
    parser.add_option('-i', '--interactive', action='store_true', help='Interactively prompt for operations')
    parser.add_option('-k', '--kill-all', action='store_true', help='Turn off all channel outputs')
#    parser.add_option('--load-compiled-sequence', action='append', metavar='FILE', help='Download compiled sequence into device')
    parser.add_option('-c', '--load-configuration-file', metavar='FILE', help='Configure device based on FILE')
#    parser.add_option('-s', '--load-sequence', metavar='FILE', action='append', help='Compile sequence(s) in FILE and download into device')
    parser.add_option('-p', '--port', metavar='PORT', help='Serial I/O port to use [%default]')
    parser.add_option('-P', '--probe', action='store_true', help='Discover Lumos devices on network')
    parser.add_option('-R', '--report', action='store_true', help='Report device status to standard output.')
    parser.add_option('-r', '--read-only', action='store_true', help="Don't read device status")
    parser.add_option('-q', '--receive', metavar='BYTES', action='store', type='int', help='read a number of bytes from device')
    parser.add_option('-s', '--script', metavar='FILE', action='store', type='str', help='Play commands from script file')
    parser.add_option('-K', '--send', metavar='HEX', action='store', help='send raw hex data to device')
#    parser.add_option('-t', '--sensor', metavar='TRIG', action='append', help='Set trigger event for sensor.')
    parser.add_option('-A', '--set-address', metavar='ADDR', type='int', help='Change unit address (0-15)')
    parser.add_option('-B', '--set-baud-rate', metavar='SPD', type='int', help='Change unit baud rate.')
    parser.add_option('-Q', '--set-phase', metavar='P', type='int', help='Change unit phase offset to P (0-511)')
    parser.add_option('-z', '--sleep', action='store_true', help='Put device into sleep mode.')
    parser.add_option('-X', '--shutdown', action='store_true', help='Shut down controller unit.')
    parser.add_option('-b', '--speed', metavar='SPD', type='int', help='Baud rate to use to talk to device. [%default]')
    parser.add_option('-Z', '--timeout', metavar='SEC', type='float', help='Read timeout [%default]')
    parser.add_option('-m', '--txdelay', metavar='mS', type='int', help='Transmitter control delay (mS) [%default]')
    parser.add_option('-L', '--txlevel', metavar='LVL', type='int', help='Transmitter control logic level (0-1) [%default]')
    parser.add_option('-T', '--txmode', metavar='MODE', action='store', choices=['dtr', 'rts'], help='Transmitter control line [%default]')
    parser.add_option('-w', '--wake', action='store_true', help='Take device out of sleep mode.')
    parser.add_option('-v', '--verbose', action='count', help='Increase output level.')
    parser.set_defaults(address=0, duplex='full', port=0, speed=19200, txmode='dtr', timeout=1, txlevel=1, txdelay=2)

    (options, operations) = parser.parse_args()

#    for sensor_opt in options.disable_sensor, options.enable_sensor:
#        if sensor_opt is not None:
#            sensor_opt = sensor_opt.upper()
#            if any([c not in 'ABCD*' for c in sensor_opt]):
#                parser.error('Sensor names are A, B, C, or D; or * for "all sensors".')

    sensor_triggers = []
#    if options.sensor is not None:
#      for trigger in options.sensor:
#        fields = trigger.upper().split(':')
#        if len(fields) != 4 or not 1 <= len(fields[0]) <= 2:
#            parser.error('-t/--sensor arg: Usage: {A|B|C|D}[o|r|w][+]:<pre>:<trigger>:<post>')
#        fields[0] = fields[0].upper()
#        m = re.match(r'^([ABCD])([ORW+-]*)$', fields[0])
#        if not m:
#            parser.error('-t/--sensor arg: Usage: {A|B|C|D}[o|r|w][+]:<pre>:<trigger>:<post>')
#
#        if '-' in m.group(2) and '+' in m.group(2):
#            parser.error('-t/--sensor arg: Sensor cannot be active high and active low at the same time!')
#
#        for f in range(1, 4):
#            try: 
#                fields[f] = int(fields[f])
#            except ValueError:
#                parser.error('-t/--sensor arg: <pre>, <trigger>, and <post> must be integers')
#
#            if not 0 <= fields[f] <= 128:
#                parser.error('-t/--sensor arg: <pre>, <trigger>, and <post> must be 0-127')
#
#        sensor_triggers.append((m.group(1), m.group(2), fields[1], fields[2], fields[3]))
    return options, operations, sensor_triggers, parser

options, operations, _, parser = parse_arguments()

api = ControlAPI(from_cli=options)
if options.probe:
    api.report_on_all_devices(options.report)
    sys.exit(0)

api.begin()
api.perform_actions_from_cli(options)

if options.script:
    api.run_script(options.script)

api.perform_operations(operations)

if options.interactive:
    api.interactive()
