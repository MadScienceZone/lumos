#!/usr/local/bin/python
# vi:set ai sm nu ts=4 sw=4 expandtab:
#
# Simple assembler for Lumos sequence bytecodes.
#
# Requires: Python 2.6 or later
#
import optparse, time, sys, re, os.path
from LumosHexFile import LumosHexFile

OPCODES = {
    'add':     ((0x13, ['$','$']),        (0x53, ['$','#'])),
    'blackout':((0x0d, None),),
    'break':   ((0x83, ['int','$']),      (0xa3, ['int']),  (0xc3, ['int','#'])),
    'call':    ((0x08, ['$','$']),        (0x28, ['$']),    (0x48, ['#','#']), (0x68, ['#'])),
    'decr':    ((0x34, ['$']),),
    'dimmer':  ((0x02, ['$','$']),        (0x42, ['#','#'])),
    'drop':    ((0x10, ['$']),            (0x30, None),     (0x50, ['#']),     (0xd0, ['[int]'])),
    'dup':     ((0x0f, None),),
    'exec':    ((0x88, ['$','$']),        (0xa8, ['$']),    (0xc8, ['#','#']), (0xe8, ['#'])),
    'exch':    ((0x11, None),),
    'exit':    ((0x00, None),),
    'fade':    ((0x04, ['$','$','$']),    (0x44, ['#','#','#'])),
    'fadeout': ((0x8d, None),),
    'ifeq':    ((0x0c00, ['int','$']), (0x4c00, ['int','#'])),
    'iflt':    ((0x0c40, ['int','$']), (0x4c40, ['int','#'])),
    'iflt':    ((0x0c80, ['int','$']), (0x4c80, ['int','#'])),
    'ifany':   ((0x0cc0, ['int','flags']),),
    'ifall':   ((0x4cc0, ['int','flags']),),
    'ifne':    ((0x8c00, ['int','$']), (0xcc00, ['int','#'])),
    'iflt':    ((0x8c40, ['int','$']), (0xcc40, ['int','#'])),
    'iflt':    ((0x8c80, ['int','$']), (0xcc80, ['int','#'])),
    'ifnone':  ((0x8cc0, ['int','flags']),),
    'ifnall':  ((0xccc0, ['int','flags']),),
    'incr':    ((0x33, ['$']),),
    'jump':    ((0x03, ['int','$']),      (0x23, ['int']),  (0x43, ['int','#'])),
    'loop':    ((0x0a, ['$']),            (0x2a, ['#0']),   (0xaa, ['#1']), (0x4a, ['#'])),
    'mul':     ((0x12, ['$','$']),        (0x52, ['$','#'])),
    'next':    ((0x0b, ['int','$','$']),  (0x2b, ['int','#1','$']), (0x6b, ['int','#1','#']), (0x4b, ['int','#','#'])),
    'nextdec': ((0x15, ['int','$','$']),  (0x35, ['int','#1','$']), (0x75, ['int','#1','#']), (0x55, ['int','#','#'])),
    'nextinf': ((0x8b, ['int','$']),      (0xab, ['int','#1']),     (0xcb, ['int','#'])),
    'nxdcinf': ((0x95, ['int','$']),      (0xb5, ['int','#1']),     (0xd5, ['int','#'])),
    'nop':     ((0x0e, None),),
    'off':     ((0x01, ['$']),            (0x41, ['#'])),
    'on':      ((0x81, ['$']),            (0xc1, ['#'])),
    'pop':     ((0x90, ['[$]']),          (0xb0, ['[0]']),   (0x70, ['{0}']), (0xf0, ['{$}'])),
    'push':    ((0x8f, ['[$]']),          (0x2f, ['#0']),    (0xaf, ['[0]']), (0x4f, ['#']), 
                                          (0xcf, ['[int]']), (0x6f, ['{0}']), (0xef, ['{$}'])),
    'ramp':    ((0x84, ['$','$','$']),    (0xc4, ['int','#','#'])),
    'resfade': ((0x86, None),),
    'resume':  ((0x06, None),),
    'sleep':   ((0x07, None),),
    'ssfb':    ((0x40, ['#']),),
    'sub':     ((0x14, ['$','$']),        (0x54, ['$','#'])),
    'suspend': ((0x05, None),),
    'suspupd': ((0x85, None),),
    'wait':    ((0x09, ['$']),            (0x49, ['#'])),
    'wake':    ((0x87, None),),
}

FLAGS = {
    'z':    0x0020,
    'v':    0x0010,
    'a':    0x0008,
    'b':    0x0004,
    'c':    0x0002,
    'd':    0x0001,
}


class NotImplemenetedError (Exception): pass
class CompilerError (Exception): pass
class SignatureMismatch (Exception): pass

def parse_arguments():
    global options
    parser = optparse.OptionParser(usage='%prog [-hLv] [-l FILE] [-o FILE] asm-files...', version='%prog, version 1.0')
    parser.add_option('-l', '--listing', metavar='FILE', action='store', help='Listing file')
    parser.add_option('-L', '--list-opcodes', action='store_true', help='Print list of opcodes and exit')
    parser.add_option('-o', '--output', metavar='FILE', action='store', help='Output (hex) file')
    parser.add_option('-v', '--verbose', action='count', help='Increase output level.')
    parser.set_defaults(verbose=0)

    (options, inputs) = parser.parse_args()
    return options, inputs, parser

def trace(level, msg, stream=sys.stderr, eol=True):
    global options
    if options.verbose >= level:
        stream.write(msg)
        if eol:
            stream.write('\n')
        else:
            stream.flush()

class CompiledSequence (object):
    def __init__(self, sequence_id):
        self.sequence_id = sequence_id
        self.symbol_table = {}
        self.current_address = 0
        self.binary = []
        self.source_code = {}

    def assemble(self, label, instruction, args, src, line_number):
        trace(4, "sequence {0}: assemble({1}, {2}, {3}) from {4}".format(self.sequence_id, label, instruction, args, src))
        if self.current_address not in self.source_code:
            self.source_code[self.current_address] = []
        self.source_code[self.current_address].append((line_number, src.rstrip()))

        if label:
            if label in self.symbol_table:
                raise CompilerError("Duplicate symbol {0} (previous definition={1})".format(label, self.symbol_table[label]))
            self.symbol_table[label] = self.current_address
            trace(4, "Symbol {0} <- {1}".format(label, self.current_address))

        if instruction:
            if instruction.lower() not in OPCODES:
                raise CompilerError("Unknown instruction {0}".format(instruction))

            for mode in OPCODES[instruction.lower()]:
                try:
                    arglist = expect_args(instruction, args, mode[1], self.symbol_table)
                    #
                    # special case for flag bits in second argument of two
                    #
                    if mode[0] > 0xff and len(mode[1]) > 1 and mode[1][1] == 'flags':
                        self.binary.extend([(mode[0] >> 8) & 0xff, mode[0] & 0xff | arglist[1], arglist[0]])
                        self.current_address += 3
                    elif mode[0] > 0xff:
                        self.binary.extend([(mode[0] >> 8) & 0xff, mode[0] & 0xff] + arglist)
                        self.current_address += len(arglist) + 2
                    else:
                        self.binary.extend([mode[0]] + arglist)
                        self.current_address += len(arglist) + 1
                    break
                except SignatureMismatch:
                    trace(4,"Attempt to match against signature {0} failed".format(mode[1]))
            else:
                raise CompilerError("Usage of {0} does not match any known addressing mode signature".format(instruction))

    def write_hex(self, fileobj):
        hf = LumosHexFile()
        fileobj.write(hf.sequence_header(self.sequence_id) + "\n")
        for i in range(0, len(self.binary), 16):
            fileobj.write(hf.data_record(self.binary[i:i+16]) + "\n")

    def write_listing(self, fileobj):
        fileobj.write("SEQUENCE #{0} ASSEMBLY LISTING\n".format(self.sequence_id))
        fileobj.write("ADDR BYTES          LINE SOURCE CODE\n")
        fileobj.write("---- -------------- ---- ----------------------------------------------------\n")
        #              --4- -------15------ --4- 
        addr = 0
        while addr < len(self.binary):
            for line in self.source_code[addr][:-1]:
                fileobj.write(" "*21 + "{0:04} {1}\n".format(line[0], line[1]))
            src_line = self.source_code[addr][-1]
            b = 4
            fileobj.write("{0:04X} {1:02X} ".format(addr, self.binary[addr]))
            addr += 1
            while addr not in self.source_code and addr < len(self.binary):
                fileobj.write("{0:02X} ".format(self.binary[addr]))
                addr += 1
                b -= 1
            if b > 0:
                fileobj.write("   " * b)
            fileobj.write("{0:04} {1}\n".format(src_line[0], src_line[1]))

        fileobj.write("\n\nSYMBOL TABLE:\n\n")
        for key in sorted(self.symbol_table):
            fileobj.write("{0:04X} {1}\n".format(self.symbol_table[key], key))
        fileobj.write("\n")

class SequenceCollection (object):
    def __init__(self):
        self.sequences = []
        self.error_count = 0

    def read_source(self, source_file_name):
        line_number = 0
        self.error_count = 0

        with open(source_file_name, 'r') as source:
            trace(1, "Reading source file {0}".format(source_file_name))
            current_sequence = None
            for line in source:
                line_number += 1
                trace(3, "Source line {0}: {1}".format(line_number, line.strip()))

                # [label:] instruction [arg[,...]] [;...]
                label = None
                instruction = None
                args = None
                m = re.search(r'^\s*(\w+)\s*:\s*(.*)', line)
                if m:
                    label = m.group(1)
                    rest = m.group(2)
                    trace(2, "recognized label {0}".format(label))
                else:
                    rest = line

                fields = re.sub(r';.*', '', rest).split()
                if fields:
                    instruction = fields[0]
                    args = (''.join(fields[1:])).split(',')
                    if len(args) == 0 or (len(args) == 1 and args[0].strip() == ''):
                        args = None
                    trace(2, "instruction='{0}', args={1}".format(instruction, args))
                elif not label:
                    trace(2, "empty line")
                    continue

                try:
                    #
                    # pseudo-ops
                    #
                    if instruction.lower() == 'sequence':
                        args = expect_args(instruction, args, ['int'])
                        current_sequence = CompiledSequence(args[0])
                        self.sequences.append(current_sequence)
                    elif instruction.lower() == 'end':
                        return
                    #
                    # sequence code
                    #
                    else:
                        if not current_sequence:
                            raise CompilerError("Statement encountered outside sequence body: {0}".format(line))
                        current_sequence.assemble(label, instruction, args, line, line_number)

                except CompilerError as e:
                    print "{0}, line {1}: ERROR: {2}".format(source_file_name, line_number, e)
                    self.error_count += 1

    def write_hex(self, fileobj):
        hf = LumosHexFile()
        for sequence in self.sequences:
            sequence.write_hex(fileobj)
        fileobj.write(hf.eof() + "\n")

    def write_listing(self, fileobj):
        for sequence in self.sequences:
            sequence.write_listing(fileobj)

def expect_args(cmd, arglist, typelist, symbol_table=None):
    trace(3,"Checking arguments {0} against types {1}".format(arglist, typelist))
    if typelist is None:
        if not arglist:
            return []
        else:
            raise SignatureMismatch("Unexpected argument{0} for {1}".format('s' if len(arglist) > 1 else '', cmd))

    if len(arglist) != len(typelist):
        if len(arglist) > len(typelist):
            raise SignatureMismatch("Extra arguments for {0} ({1} expected)".format(cmd, len(typelist)))
        else:
            raise SignatureMismatch("Not enough arguments for {0} ({1} expected)".format(cmd, len(typelist)))

    newlist = []
    for t,v in zip(typelist, arglist):
        v = v.strip()
        if t == 'int':
            newlist.append(parse_int_value(v, symbol_table))

        elif t in ('$', '[$]', '{0}', '{$}'):
            if not (v == t or re.sub(r'\s*', '', v) == t):
                raise SignatureMismatch("Expected {0}, got {1} for {2}".format(t, v, cmd))

        elif t == '[int]':
            if v.startswith('[') and v.endswith(']'):
                newlist.append(parse_int_value(v[1:-1], symbol_table))
            else:
                raise SignatureMismatch("Expected [int], got {0}".format(v))

        elif t == 'flags':
            bits = 0
            for bit in v.lower():
                if bit == '|':
                    continue

                if bit not in FLAGS:
                    raise CompilerError("Expected flag names in argument to {0}, got {1}".format(cmd, v))

                bits |= FLAGS[bit]
            newlist.append(bits)

        elif t == '#0':
            if v.startswith('#') and parse_int_value(v[1:], symbol_table) == 0:
                pass
            else:
                raise SignatureMismatch("Expected #0, got {0}".format(v))
            
        elif t == '#1':
            if v.startswith('#') and parse_int_value(v[1:], symbol_table) == 1:
                pass
            else:
                raise SignatureMismatch("Expected #1, got {0}".format(v))

        elif t == '#':
            if v.startswith('#'):
                newlist.append(parse_int_value(v[1:], symbol_table))
            else:
                raise SignatureMismatch("Expected immediate value, got {0}".format(v))

        elif t == '[0]':
            if v.startswith('[') and v.endswith(']') and parse_int_value(v[1:-1], symbol_table) == 0:
                pass
            else:
                raise SignatureMismatch("Expected [0], got {0}".format(v))

        else:
            raise NotImplementedError("Internal Error: unimplemented type coercion to {0} for value {1}".format(t, v))

    return newlist

def parse_int_value(v, symbol_table):
    try:
        if v.startswith('0x'):
            return (int(v, 16))
        elif v.startswith('0'):
            return (int(v, 8))
        else:
            m = re.match(r'^\s*([a-zA-Z_]\w*)\s*$', v)
            if m:
                if m.group(1) not in symbol_table:
                    raise CompilerError("Undefined symbol {0}".format(m.group(1)))
                return symbol_table[m.group(1)]
            
            return (int(v))
    except ValueError as e:
        raise CompilerError("Invalid integer constant value {0} ({1})".format(v, e))

                    
        
    
                    





                    
                



def main():
    options, inputs, parser = parse_arguments()
    hex_file = None
    list_file = None

    if options.listing:
        list_file = open(options.listing, 'w')

    print "Lumos Sequence Assembler version 1.0"

    if options.list_opcodes:
        for instruction in sorted(OPCODES):
            for mode in OPCODES[instruction]:
                if mode[0] > 0xff:
                    print "{2:04X} {0:8}{1}".format(instruction, '' if mode[1] is None else ','.join(mode[1]), mode[0])
                else:
                    print "{2:02X}   {0:8}{1}".format(instruction, '' if mode[1] is None else ','.join(mode[1]), mode[0])
        sys.exit(0)

    for source_file in inputs:
        if not hex_file:
            output_name = options.output or os.path.splitext(source_file)[0] + '.hex'
            trace(1,"Writing to {0}".format(output_name))
            hex_file = open(output_name, 'w')

        sequences = SequenceCollection()
        sequences.read_source(source_file)

    trace(1,"Writng hex output...")
    sequences.write_hex(hex_file)
    hex_file.close()

    if list_file:
        trace(1,"Writing listing...")
        sequences.write_listing(list_file)
        list_file.close()



    print "SEQUENCES: {0:03}".format(len(sequences.sequences))
    print "ERRORS:    {0:03}".format(sequences.error_count)

if __name__ == '__main__':
    main()
