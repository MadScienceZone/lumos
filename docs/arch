UI sees sequences as set of (t,c,ch,v) events with normalized value like
real percentages or 0-255
	sequence event types:
		on
		off
		all off
		kill
		all kill
		level(n)
		fade(start,end,interval)
		*repeats?
		*subsequences?
		*background tracks?
	
Sequence builder looks at devices, resolutions, etc to build event list
for playback, something like (t,c,ch,rawval) or even (t,net,bytes)


EventType objects?
	
	set value to n over time delta t
		that pretty much sums it all up for light controllers, not for
		other things like readerboards, but we still have to figure out
		how those work with Lumos anyway.
	

sequence:
	list of timed events:
		(time, controller, channel, value)
		(ms, controller_obj, method_obj, arglist)

controller (ControllerUnit class):
	sends events to network

	default
		ids are strings (index into channels dict)

	FireGodControllerUnit
		ids are integer indexes into channels list
	X10ControllerUnit
		ids are in form "A1".."P16"
	   FirecrackerX10ControllerUnit
	 	packet(id, op) -> bytes to send to device
	   LynX10ControllerUnit
	LumosControllerUnit
		throws {DeviceProtocol,InternalDevice,Internal}Error
		ids are integer indexes into channels list
		.dumpstats(filename)
		.raw_ramp_up(ch, steps, delay, cycle=False)
		.raw_ramp_down(ch, steps, delay, cycle=False)
		.raw_control(cmd_name, ...)
		.raw_begin_rom_download(...)
		.raw_set_phase(v)
		.raw_set_address(a)
		.raw_download_sequence(id, bits)
		.raw_sensor_trigger(sensor, pre, seq, post, inverse=False, execf=False)
		.raw_configure_device(conf_obj)
		.raw_query_device_status(timeout=0) -> LumosControllerStatus
	LumosLegacyControllerUnit
		(for units with 2.x ROMs)
	Olsen595ControllerUnit
	RenardControllerUnit
	SpectrumReaderboardUnit
		throws InvalidTextAlignment, InvalidTextMode, InvalidTextAttribute
	UltraDMXMicroControllerUnit
		throws DeviceProtocolError
	 	

	__init__(id, power_source, network, [resolution=100], ...)
		FireGodControllerUnit:	+address=1, num_channels=32
		LumosControllerUnit:	+address=0, num_channels=48
		LumosLegacyControllerUnit: +address
		Olsen595ControllerUnit:	+num_channels=64
		RenardControllerUnit:	+address=0, num_channels=64
		UltraDMXMicroControllerUnit: +num_channels=512
	channel_id_from_string(channel)	# channel name -> id
		FireGodControllerUnit:	-> int
	add_channel(id, [name], [load], [dimmer=True], [warm], [resolution], [power_source])
	set_channel(id, level, [force=False])
		id can be string or int depending on type of unit
		level is number (int? float? %? raw?) or None
			None: turn completely off as opposed to dim down to 0%
	set_channel_on(id, [force=False])
	set_channel_off(id, [force=False])
	kill_channel(id, [force=False])
		kill is like off but ignores warm setting
	kill_all_channels([force=False])
	all_channels_off([force=False])
	initialize_device()
	flush([force=False])
		calls network.send with the binary data
	iter_channels()			# iterates over channel IDs
	_iter_non_null_channel_list()	# only includes implemented channels
	current_drain()			# -> {chan_id: (amps, PowerSource), ...}
	current_loads()			# -> {chan_id: (amps, PowerSource), ...}
	__str__()			# human readable description of controller

channel:
	__init__(id, [name], [load], [dimmer], [warm], [resolution])
	raw_dimmer_value(pct) -> nn   (None->0)
	pct_dimmer_value(nn) -> pct   (None->0)
	normalized_value(pct, [override]) -> pct' (adjusted for warm limit)
	set_level(newlevel, [override]) -> (oldraw, newraw)
		enforces warm, max/min limits
	set_on()
	set_off()
	kill()
		
