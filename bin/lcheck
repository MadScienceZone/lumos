#!/usr/bin/env python
# vi:set ai sm nu ts=4 sw=4 expandtab:
#
# LUMOS CONFIGURATION CHECK UTILITY
# $Header: /tmp/cvsroot/lumos/bin/lcheck,v 1.5 2009-01-04 21:43:48 steve Exp $
#
# Lumos Light Orchestration System
# Copyright (c) 2005, 2006, 2007, 2008, 2009 by Steven L. Willoughby, Aloha,
# Oregon, USA.  All Rights Reserved.  Licensed under the Open Software
# License version 3.0.
#
# This product is provided for educational, experimental or personal
# interest use, in accordance with the terms and conditions of the
# aforementioned license agreement, ON AN "AS IS" BASIS AND WITHOUT
# WARRANTY, EITHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION,
# THE WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A
# PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY OF THE ORIGINAL
# WORK IS WITH YOU.  (See the license agreement for full details, 
# including disclaimer of warranty and limitation of liability.)
#
# Under no curcumstances is this product intended to be used where the
# safety of any person, animal, or property depends upon, or is at
# risk of any kind from, the correct operation of this software or
# the hardware devices which it controls.
#
# USE THIS PRODUCT AT YOUR OWN RISK.
# 
import Lumos
from optparse   import OptionParser
from Lumos.Show import Show
import sys
#@@REL@@sys.tracebacklimit=0

#========================================================================
# Command-line option processing
#========================================================================

parser = OptionParser(usage="%prog [-hv] config-files...", version='@@RELEASE@@')
parser.add_option('-v', '--verbose', action='store_true', help='Enable more descriptive output')
(options, files) = parser.parse_args()

for file in files:
    if options.verbose: print "Checking", file
    s = Show()
    s.load(open(file), open_device=False)
    if options.verbose:
        print "SHOW DESCRIBED BY FILE '%s':" % file
        print " Title:", s.title
        print " Description:", s.description
        print "-" * 78
        print " POWER SOURCES:"
    maxload_W = {}
    unitnames = {}
    for sourceID in sorted(s.all_power_sources):
        source = s.all_power_sources[sourceID]
        maxload_W[sourceID] = 0
        if options.verbose: print "  %-10s %5gA %5gV %6dW" % (source.id, source.amps, source.volts, source.amps*source.volts)

    if options.verbose:
        print "-" * 78
        print " COMMUNICATIONS PARAMETERS"
        print "  NETWRK SPEED  BPSXR PORT       DESCRIPTION"
        for netID in sorted(s.networks):
            net = s.networks[netID]
            X=R='-'
            if net.xonxoff: X='X'
            if net.rtscts:  R='R'
            
            print "  %-6s %6d %d%s%d%s%s %-10s %s" %(
                netID, net.baudrate, net.bits, net.parity[0],
                net.stop, X, R, net.port, net.description)

    if options.verbose:
        print "-" * 78
        print " DEVICE CONTROLLERS:"
        print "  NETWRK UNIT     POWER DESCRIPTION"
        for netID in sorted(s.networks):
            net = s.networks[netID]
            for unitID in sorted(net.units):
                unit = net.units[unitID]
                print "  %-6s %-8s %5s %s" % (netID, unitID, unit.power_source.id, unit)
            
        print "-" * 78
        print " DEVICE CHANNELS:"
        print "  UNIT     CHAN POWER   LOAD D WARM DESCRIPTION"

    for netID in sorted(s.networks):
        net = s.networks[netID]
        for unitID in sorted(net.units):
            unit = net.units[unitID]
            if unitID in unitnames:
                raise ValueError, "Unit '%s' is not unique!" % unitID
            unitnames[unitID] = 1
            for chanID in sorted(unit.iter_channels()):
                channel = unit.channels[chanID]
                channel_power, channel_source = channel.current_load()
                if options.verbose:
                    D = '-'
                    if channel.dimmer: D = 'D'
                    print "  %-8s %4s %-6s %4.2gA %s %3d%% %s" %(
                        unitID, chanID, channel_source.id, channel_power, D,
                        channel.pct_dimmer_value(channel.warm), channel.name)
                maxload_W[channel_source.id] += channel_power * channel_source.volts
    
    if options.verbose:
        print "-" * 78
        print " POWER LOAD SUMMARY:"


    def trace_load_of(pso, maxload_W):
        ps = pso.id
        pso_watts = pso.amps * pso.volts
        psmax_W = maxload_W[ps]
        total_W = psmax_W + sum([trace_load_of(ss, maxload_W) for ss in pso.subordinates])
        
        if options.verbose:
            print "  {0:10s} Loaded to {1:3d}%".format(ps, int(total_W*100 // pso_watts))

        if total_W > pso_watts:
            over = -(pso_watts - total_W)
            print "*** WARNING *** {0} OVERLOADED BY {1} AMP{2} ({3} WATT{4}) IF ALL CHANNELS ON!".format(
                ps, over/pso.volts, "S" if (over/pso.volts) != 1 else "",
                over, "S" if over != 1 else "")
        elif total_W == pso_watts:
            print "*** WARNING *** {0} AT 100% LOAD CAPACITY IF ALL CHANNELS ON!".format(ps)
        elif total_W/float(pso_watts) > 0.80:
            print "*** WARNING *** {0} NEAR CAPACITY ({1:d}%)".format(
                    ps, int(total_W*100 // pso_watts))

        return total_W



    total_W=0
    for ps in sorted(s.top_power_sources):
        total_W += trace_load_of(s.all_power_sources[ps], maxload_W)

    if options.verbose:
        print "Total allocated load: {0} Watts".format(total_W)


#    for ps in sorted(s.all_power_sources):
#        if options.verbose:
#            print "  %-10s Loaded to %3d%%" % (ps, ((maxload[ps]*100) // s.all_power_sources[ps].amps))
#        if maxload[ps] > s.all_power_sources[ps].amps:
#            over = -(s.all_power_sources[ps].amps - maxload[ps])
#            print "*** WARNING ***", ps, "OVERLOADED BY", over, \
#                ("AMPS" if over != 1 else "AMP"), "IF ALL CHANNELS ON!"
#        elif maxload[ps] == s.all_power_sources[ps].amps:
#            print "*** WARNING ***", ps, "AT 100% LOAD CAPACITY IF ALL CHANNELS ON!"
#        elif maxload[ps]/float(s.all_power_sources[ps].amps) > 0.80:
#            print "*** WARNING ***", ps, "NEAR CAPACITY (%d%%)" % ((maxload[ps]*100) // s.all_power_sources[ps].amps)
#
# $Log: not supported by cvs2svn $
# Revision 1.4  2008/12/31 00:25:19  steve
# Preparing 0.3a1 release
#
# Revision 1.3  2008/12/30 22:58:02  steve
# General cleanup and updating before 0.3 alpha release.
#
#
