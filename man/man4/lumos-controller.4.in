.TH LUMOS-CONTROLLER 4 "Lumos" "Mad Science Zone" "Device Drivers"
'\"
'\" LUMOS DOCUMENTATION:
'\" $Header: /tmp/cvsroot/lumos/man/man4/lumos-controller.4,v 1.2 2008-12-30 22:58:02 steve Exp $
'\"
'\" Lumos Light Orchestration System
'\"@@COPYRIGHT@@
'\"
'\" This product is provided for educational, experimental or personal
'\" interest use, in accordance with the terms and conditions of the
'\" aforementioned license agreement, ON AN "AS IS" BASIS AND WITHOUT
'\" WARRANTY, EITHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION,
'\" THE WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A
'\" PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY OF THE ORIGINAL
'\" WORK IS WITH YOU.  (See the license agreement for full details, 
'\" including disclaimer of warranty and limitation of liability.)
'\"
'\" Under no curcumstances is this product intended to be used where the
'\" safety of any person, animal, or property depends upon, or is at
'\" risk of any kind from, the correct operation of this software or
'\" the hardware devices which it controls.
'\"
'\" USE THIS PRODUCT AT YOUR OWN RISK.
'\" 
.SH NAME
lumos-controller \- Lumos controller device driver implementation notes
.SH DESCRIPTION
.LP
The Lumos light circuit sequencing program was designed to be extended for
use with arbitrary controller hardware by \*(lqplugging in\*(rq device drivers 
for new types of controllers.  This document describes the general design
of Lumos' driver system and how one would go about writing a new driver
for Lumos.
.LP
The Lumos program is implemented in Python, and the device drivers are simply
Python modules which each define an object class describing a particular type
of hardware controller.  
.SS "Theory of Operation"
.LP
Each device driver class describes a certain kind of hardware device.
The main application software will create an instance of each driver class
for each controller described in the show configuration file,
and will then call the
.B add_channel()
method in each, to set up the active channels used in the show.  (Your device
driver should not depend on all physical channels being constructed, nor
should it assume that unused channels
.I won't
be.)  Finally, as a last step before the show sequences begin, the driver's
.B initialize_device()
method is called.
.LP
During the operation of the show, various channel manipulation methods
(such as
.BR set_channel() )
are called to make changes in each device's outputs.  These methods 
can invoke the 
.B self.network.send()
method to pass the appropriate command codes immediately to the hardware.
Some kinds of controllers might choose to buffer up several state changes 
before actually transmitting command bytes.  For example, a device requiring 
all channel data to be sent for each update (e.g., the \*(lqOlson 595\*(rq),
may not actually send anything to the network yet.  When all the changes for a 
given time event are set, Lumos will call the 
.B flush()
method in each controller.  This will allow those controllers to know it's
time to send their bulk update data to the device.
.LP
No device is expected to ever send data back to Lumos; these drivers are 
write-only.
.SS "Definition of the Controller Class"
.LP
Each controller driver is a separate module (and therefore stored in its own 
file).  To start a new controller, create a file with an appropriate name
such as 
.RB \*(lq WhizzoLightController.py \*(rq.
.LP
All controller driver classes are subclasses of 
.BR ControllerUnit ,
which is an abstract base class describing the essential attributes and 
behaviors of all controller types.  If you haven't already done so, look
over the documentation for that module (the simplest way is to type the
command
.RB \*(lq "pydoc Lumos.ControllerUnit" \*(rq
from inside the Lumos source directory (or from anywhere once Lumos is installed
on your system).
.LP
Note also that where there are some general groupings of similar kinds of 
controllers, intermediate classes have been created.  Thus, while 
.B LumosController
is a direct subclass of 
.BR ControllerUnit ,
.B FirecrackerX10ControllerUnit
and 
.B LynX10ControllerUnit
are subclasses of
.BR X10ControllerUnit ,
which is itself a subclass of
.BR ControllerUnit .
In this way, all the general X-10 controller behavior can be implemented by
the 
.B X10ControllerUnit
class, and only specific differences applicable to the LynX-10 and Firecracker X-10 controllers are implemented in their respective classes.  If you are designing a new driver, have your controller object class inherit from the closest 
existing base class, or from
.B ControllerUnit
if it's completely unique.
.SS "Extending the Controller Class"
.LP
You need to extend the base 
.B ControllerUnit
class by adding the following methods as appropriate for your device.
In each case, check with the 
.B ControllerUnit
and
.B Channel
object class definitions (using 
.B pydoc
for example) and 
.I "do not deviate from the call signatures"
indicated there (as far as number or position of arguments, which are optional, etc.)
.LP
You MUST define device-specific versions of these methods (unless you
are inheriting from an intermediate class which does define them sufficiently):
.TP
.BI channel_id_from_string( chan )
Returns a channel ID in the approprate type (integer, string, etc.) as
expected (i.e., for indexing 
.BR self.channels ), 
given a string representation of that channel's name.
.TP
.BI all_channels_off( \fR[\fPforce\fR]\fP ) 
Turns off all device channels.  In this case,
\*(lqoff\*(rq means to take the channels to the minimum allowed level
(which is either fully off, or the
.I warm
value set for that channel).
As with all of the following methods which
change channel state, this needs to update the channel state information
within the driver (usually a set of
.B Channel
objects) and then send the appropriate set of commands to the hardware
via the
.B self.network.send()
method (or track state and wait until
.B flush()
is called).
It MAY send the device updates immediately, or it may coose to suppress commands
to the hardware if it believs the ouput of a channel is already at the desired
level.  If the 
.I force
argument is True, then no such optimization will be performed, and every valid
Lumos command will be carried out.
.TP
.B initialize_device()
Performs whatever setup is necessary to ensure that the controller is on-line,
with all channels off, and ready to begin receiving commands.
.TP
.BI kill_all_channels( \fR[\fPforce\fR]\fP )
Just like
.BR all_channels_off() ,
except that all channels are turned completely off, even if any have minimum
.I warm
values defined for them.
(See
.B all_channels_off()
for an explanation of the
.I force
parameter.)
.TP
.BI kill_channel( id ", " \fR[\fPforce\fR]\fP )
Kills a specific channel output, turning it complely off regardless of
any
.I warm
setting in effect.
(See
.B all_channels_off()
for an explanation of the
.I force
parameter.)
.TP
.BI set_channel( id ", " level ", \fR[\fP" force "\fR]\fP)"
This should interact with the 
.B Channel
object associated with the given
.I id
for this controller, instructing it to set its value to
.IR level .
(See
.B all_channels_off()
for an explanation of the
.I force
parameter.)
.TP
.BI set_channel_off( id ", " \fR[\fPforce\fR]\fP )
Turns off (respecting any minimum
.I warm
level) the specified channel.
(See
.B all_channels_off()
for an explanation of the
.I force
parameter.)
.TP
.BI set_channel_on( id ", " \fR[\fPforce\fR]\fP )
Turns the specified channel fully on.
(See
.B all_channels_off()
for an explanation of the
.I force
parameter.)
.\" .LP
.\" You SHOULD define extensions of these methods:
.LP
You MAY, but possibly won't need to, extend the following methods:
.TP
.RI \fBadd_channel(\fP id ", [" name "], [" load "], [" dimmer "], [" warm "], [" resolution "], [" power "], ...\fB)\fP"
This method will be called by the Lumos application based on the
show configuration data, to assign active channels to your controller 
unit.  The default implementation of 
.B add_channel()
is a 
.B Channel
object factory which creates a new
.B Channel
instance and stores it in the controller's 
.B channels
attribute.  That's usually sufficient.
.RS
.LP
Note that this method will be passed the 
fields from the show configuration file
as keyword arguments.  
Except for the
.IR load ,
.IR dimmer ,
.IR warm ,
and
.I power
fields, which are appropriate native types, the fields will be strings
as written in the configuration file.
.RE
.TP
.BR __init__( ... )
In most cases it should be unnecessary to override the class constructor
you inherit from
.BR ControllerUnit .
This will create the following attributes which your other methods may use:
.RS
.TP
.B power_source
A reference to the 
.B PowerSource
object supplying power to this unit, as passed in the
.I power
argument to the constructor function.
(Note that it is possible for individual channels to override this
value if they are supplied power from another source, as is possible
with X-10 and Lumos controllers for example.  This value is the default
inherited by this controller's channels.)
.TP
.B resolution
Dimmer resolution as passed in the
.I resolution
constructor argument.  This will be whatever was passed
or the value 100 if nothing was passed when the new
controller object was created.  If your device has a different
resolution default, you can either make your own constructor
to offer that different default, or just handle it in your
.B add_channel()
method.
.TP
.B channels
The constructor also creates an empty collection (which
may be a list or dictionary or something else as long as
the channel ID values returned by
.B channel_id_from_string()
can be used as subscripts to the
.B channels
attribute) to hold the 
channel objects for this controller, so your
.B add_channel()
method can simply add to this exsiting attribute.
.TP
.B id
The controller unit instance's id.
.LP
Note that the constructor function for a given class will be passed the 
fields from the config file
as keyword arguments.  The 
.I type
field is not passed.  The
.I power
field value will be a
.B PowerSource
class object instance.  The rest will be strings as written in
config file.
.LP
One addittional parameter passed to the constructor is
.IR network ,
which is a reference to the network driver object this particular device is 
connected to.
.RE
.TP
.B flush()
For devices which batch up bulk update command sequences, this method is
their cue to flush out all pending changes to the hardware.  The default
.B flush()
method does nothing (most known devices at the time Lumos was written do
not operate this way).
.TP
.B iter_channels()
Returns an iterator over the list of channel ids defined for use
in this show.  The base class
.B ControllerUnit
defines a default
.B iter_channels()
method which returns a simple iterator over the collection
.BR self.channels .
Just letting your class inherit this from
.B ControllerUnit
is sufficient if your
.B channels
attribute is a dictionary or a list whose elements will
always be defined and active in the show.  However, if
your
.B channels
collection is a simple list but not all channels might be
defined by the show configuration file (and therefore 
your
.B add_channel()
method might not be called for every one of them), then
.B iter_channels()
should return an iterator which only yields the list of
channel indices actually defined for this show.  The
.B ControllerUnit
base class provides a sample method which does this as
well:
.BR _iter_non_null_channel_list() .
If you have this kind of
.B channels
collection, just redefine your
.B iter_channels()
method to this instead.  For example, in your class'
.B __init__()
method, you can do this:
.RS
.na
.nf
.B "self.iter_channels = self._iter_non_null_channel_list"
.fi
.ad
.RE
.LP
Since the drivers which ship with Lumos are available as source files,
it would be instructive to examine them as a pattern to follow when creating
new drivers.
.SS "Registering Your Device Driver"
.LP
The 
.RB \*(lq Controllers \*(rq
module provides a mapping from the controller device names presented to the
user (e.g., those usable in the
.B show.conf
file's description of controller types), and which actual device driver module
to use to actually control the hardware.
.LP
To add your new driver to the list, simply edit 
.B Controllers.py
and add two lines: an import statement to import the driver class,
and an entry in the
.B supported_controller_types
dictionary.  
For example, if we called our controllers \*(lqwhizzo\*(rq in all the
user-visible areas of Lumos, the first few lines of the
.B Controllers.py
file might look like this:
.RS
.na
.nf
\&.
\&.
\&.
.B "from WhizzoControllerUnit import WhizzoControllerUnit"
.B "supported_controller_types = {"
.B "\ \ \ 'lynx10':  LynX10ControllerUnit,"
.B "\ \ \ 'lumos':   LumosControllerUnit,"
.B "\ \ \ 'cm17a':   FirecrackerX10ControllerUnit,"
.B "\ \ \ 'whizzo':  WhizzoControllerUnit,"
.B }
\&.
\&.
\&.
.fi
.ad
.RE
.SH VERSION
.LP
This document covers the @@VERSION@@ release of Lumos.
.SH COPYRIGHT
.LP
Lumos Light Orchestration System,
..@@COPYRIGHT@@
.SH AUTHOR
.LP
Steve Willoughby, support@madscience.zone
.SH "SEE ALSO"
.BR lumos (1),
.BR lumos-config (5),
.BR lumos-network (4).
.LP
Also refer to the \*(lqHACKING\*(rq document supplied with the Lumos
source code.
.SH BUGS
'\" 
'\" $Log: not supported by cvs2svn $
'\" 
