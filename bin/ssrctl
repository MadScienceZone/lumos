#!/usr/bin/python
# vi:set ai sm nu ts=4 sw=4 expandtab:
#_______________________________________________________________________ 
#                                                                 Lumos #
#                                                                 0.0.0 #
#                                                           SSR Control #
#                                                               Utility #
#_______________________________________________________________________#
#
# Load and play a sequence of events in real time

import Lumos
from Lumos.Show     import Show
from Lumos.Sequence import Sequence
from Lumos.Event    import Event
from optparse       import OptionParser
import sys, re, sched, time
#@@REL@@sys.tracebacklimit=0

#========================================================================
# Command-line option processing
#========================================================================

# commands:
#  [<unit>|*][.<channel>|*][=<value>[/msec] | ? | k]
#  
parser = OptionParser(usage="%prog [-hTvz] [-c config] [commands...]", version='0.0')
parser.add_option('-c', '--config',  metavar='FILE', help='Specify config file [./lumos.conf]')
parser.add_option('-T', '--test',    action='store_true', help="Describe actions, don't actually do them")
parser.add_option('-v', '--verbose', action='store_true', help='Enable more descriptive output')
#parser.add_option('-z', '--zero',    action='store_true', help='Zero all channels first')
parser.set_defaults(config='lumos.conf')
(options, command_list) = parser.parse_args()

#========================================================================
# Create show object from config file
#========================================================================

show = Show()
show.load_file(options.config, open_device=(not options.test))

seq = Sequence()

#========================================================================
# Functions to support --test mode (real time trace of what actions
# would have been taken on a real run)
#========================================================================

def trace_event(str):
    print '::TEST::', str

def trace_event_format(func, arglist):
    '''
Output format for traced events via --test option:
::TEST:: <controller>: <action>
    '''
    try:
        obj_name = func.im_self.id
    except:
        try:
            obj_name = 'unknown ' + `func`
        except:
            obj_name = 'unknown'

    return obj_name + ': ' + func.__name__ + `arglist`
    

#========================================================================
# 
#========================================================================

if options.verbose:
    print "Lumos SSR Control Utility, version", parser.version
    print "Show:", show.title
    print "     ", show.description

interactive_mode = False
if len(command_list) == 0:
    interactive_mode = True

def fail(message):
    global interactive_mode

    if interactive_mode:
        print message
    else:
        print >>sys.stderr, "Fatal error:", message
        sys.exit(1)

current_controller = None
current_channel = None
def do_command(command):
    global current_controller, current_channel

    #
    # Interpret a command from standard input or the command line.
    #
    # A command consists of these parts:
    # [<unit>.]
    #   unit name ("*" for all units).  If no unit is specified, use
    #   the unit from the previous command.
    # [<channel>]
    #   channel name or number ("*" for all channels of the unit)
    #   If no channel is specified, use the channel from the previous
    #   command.
    # <action>
    #   What to do to the specified unit(s)/channel(s). This can be
    #   one of the following:
    #     =<value>[/<time>]
    #       set output level to <value> percent (a floating point value
    #       between 0 and 100).  Normally this is instantaneous, but if
    #       you want to gradually effect the change, append a slash
    #       followed by an integer number of milliseconds during which
    #       the transition should take place.
    #     :k
    #       kill channel (may be different from "=0" for some kinds 
    #       of devices.  Kills power even if a "warm" configuration
    #       specifies a minimum value, which is different from "=0".
    #     :p
    #       print the current state of the channel(s).
    #     :x
    #       turn OFF channel (may be different from "=0" for some kinds
    #       of devices).  Respects "warm" configuration values.
    #
    m = re.match(r'((?P<unit>(\w+|\*))\.)?(?P<channel>(\w+|\*))?(=(?P<level>\d+(\.\d+)?)(/(?P<time>\d+))?|:(?P<cmd>[kpx]))', command)
    if not m:
        fail("Can't understand command \"" + command + '"')
        return

    if m.group('unit'):
        current_controller = m.group('unit')
        current_channel = None

    if m.group('channel'):
        current_channel = m.group('channel')

    if current_controller == '*':
        controller_obj = None
        if current_channel != '*':
            fail('If the controller is "*", then channels must also be "*".')
            return
    else:
        if current_controller in show.controllers:
            controller_obj = show.controllers[current_controller]
        else:
            fail('No such controller unit "' + current_controller + '"')
            return

    if current_channel == '*':
        channel_id = None
    else:
        channel_id = controller_obj.channel_id_from_string(current_channel)

    if m.group('level'):
        # set channel(s) to certain level.
        # to make this easier, especially with multiple channels
        # and time intervals, we just use the Sequence class to
        # convert and compile the device-specific (and timed)
        # events.
        try:
            level = float(m.group('level'))
        except:
            fail('New level value must be a percentage from 0.0 to 100.0.')
            return

        if m.group('time'):
            try:
                time_interval = int(m.group('time'))
            except:
                fail('Time interval must be an integer number of milliseconds.')
                return
        else:
            time_interval = 0

        seq.clear()
        seq.add(0, Event(controller_obj, channel_id, level, time_interval))
        schedule = sched.scheduler(time.time, time.sleep)
        if options.test:
            for time_stamp, method, arglist in seq.compile(keep_state = True):
                schedule.enter(time_stamp / 1000.0, 0, trace_event, 
                    (trace_event_format(method, arglist),))
        else:
            for time_stamp, method, arglist in seq.compile(keep_state = True):
                schedule.enter(time_stamp / 1000.0, 0, method, arglist)

        schedule.run()
    else:
        # perform a command on each controller and channel specified.
        if controller_obj is None:
            controllers = show.controllers.values()
        else:
            controllers = [controller_obj]

        for c_obj in controllers:
            if channel_id is None:
                chans = c_obj.iter_channels()
            else:
                chans = [channel_id]

            for chan in chans:
                if m.group('cmd') == 'k':
                    c_obj.kill_channel(chan)
                elif m.group('cmd') == 'p':
                    if c_obj.channels[chan].level is None:
                        print "%s.%s = OFF" % (c_obj.id, chan)
                    else:
                        print "%s.%s = %d (%.1f%%)" % (c_obj.id, chan, c_obj.channels[chan].level, 
                            c_obj.channels[chan].pct_dimmer_value(c_obj.channels[chan].level))
                elif m.group('cmd') == 'x':
                    c_obj.set_channel_off(chan)
                else:
                    fail('BUG: Unrecognized (and uncaught!) command "%s".' % m.group('cmd'))
                    return

if interactive_mode:
    print '''Lumos SSR Control Utility
To set a channel's level:
   > [[controller.]channel]=percentage[/time]
   If time given, make change over that many milliseconds
To turn a channel OFF (may be different than 0% level)
   > [[controller.]channel]:x
To kill a channel's output (like off/0% but ignores "warm" level)
   > [[controller.]channel]:k
To print current state of a channel
   > [[controller.]channel]:p

If controller or channel name omitted, reuse one from previous command.
Either controller or channel may be "*", which means "all".  So, turning
all outputs on all controllers fully off is "*.*:k".

Type EOF (^D on Unix; ^Z on Windows/DOS) to quit.
'''


    while True:
        try:
            do_command(raw_input("> "))
        except EOFError:
            print
            sys.exit(0)
else:
    for command in command_list:
        do_command(command)
