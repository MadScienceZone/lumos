#!/usr/bin/env python
# vi:set ai sm nu ts=4 sw=4 expandtab:
#
# Download a new firmware image to a Lumos controller.
#
# Requires: Python 2.6 or later
#           Lumos
#
import optparse, time, sys, re
import ConfigParser
import Lumos
from   Lumos.Network.SerialNetwork      import SerialNetwork, DeviceTimeoutError
from   Lumos.Device.LumosControllerUnit import LumosControllerUnit, LumosControllerStatus
from   Lumos.Show                       import Show
from   Lumos.PowerSource                import PowerSource

class NotImplemenetedError (Exception): pass
class NotSupportedError (Exception): pass
class HardwareNotReady (Exception): pass

def parse_arguments():
    global options
    parser = optparse.OptionParser(usage='%prog [-fhNnRv] -a ADDR [-b SPD] [-L txlevel] [-m txdelay] [-p port] [-T txmode] image-file', version='%prog, version 1.0')
    parser.add_option('-a', '--address', metavar='ADDR', type='int', help='Unit address (0-15)')
    parser.add_option('-f', '--force',   action='store_true', help='Force upgrade without prompting')
    parser.add_option('-p', '--port', metavar='PORT', help='Serial I/O port to use [%default]')
    parser.add_option('-b', '--speed', metavar='SPD', type='int', help='Baud rate to use to talk to device. [%default]')
    parser.add_option('-m', '--txdelay', metavar='mS', type='int', help='Transmitter control delay (mS) [%default]')
    parser.add_option('-N', '--null-device', action='store_true', help="Don't actually talk to a Lumos device (implies -n)")
    parser.add_option('-n', '--dry-run', action='store_true', help="Don't actually change anything")
    parser.add_option('-R', '--resume', action='store_true', help="Continue an interrupted download")
    parser.add_option('-L', '--txlevel', metavar='LVL', type='int', help='Transmitter control logic level (0-1) [%default]')
    parser.add_option('-T', '--txmode', metavar='MODE', action='store', choices=['dtr', 'rts'], help='Transmitter control line [%default]')
    parser.add_option('-v', '--verbose', action='count', help='Increase output level.')
    parser.add_option('-d', '--duplex', metavar='TYPE', action='store', choices=['full','half'], help="full or half-duplex operation [%default]")
    parser.set_defaults(duplex='full', port=0, speed=19200, txmode='dtr', txlevel=1, txdelay=2)

    (options, file_names) = parser.parse_args()
    if options.null_device:
        options.dry_run = True

    #
    # validate options
    #
    if options.address is None:
        parser.error('--address (-a) option is required.')

    if not 0 <= options.address <= 15:
        parser.error('Valid unit addresses are in the range 0..15 only')

    if options.duplex not in ['full', 'half']:
        parser.error('--duplex value must be "full" or "half".')

    if options.txmode not in ['dtr', 'rts']:
        parser.error('--txmode value must be "dtr" or "rts".')

    if not 0 <= options.txlevel <= 1:
        parser.error('--txlevel value must be 0 or 1.')

    if not 0 <= options.txdelay <= 127:
        parser.error('--txdelay value must be 0-127.')

    return options, file_names, parser

def setup_lumos(options):
    #
    # Build Lumos context
    #
    show = Show()
    show.title = 'lumosupgrade'
    show.description = 'Lumos Firmware Upgrade Utility'

    ps = PowerSource('power')

    io = SerialNetwork(
        description='Serial port for Lumos devices',
        port = options.port,
        baudrate = options.speed,
        bits = 8,
        parity = 'none',
        stop = 1,
        xonxoff = False,
        rtscts = False,
        duplex = options.duplex,
        txmode = options.txmode,
        txlevel = options.txlevel,
        txdelay = options.txdelay,
        open_device = not options.null_device
    )

    target = LumosControllerUnit(
        id = 'target',
        power_source = ps,
        network = io,
        address = options.address,
        resolution = 256,
        num_channels = 48,
    )

    show.add_network('io', io)
    show.add_controller('io', target)
    for channel_id in range(48):
        target.add_channel(channel_id, load=0)

    return target, io

def getstatus(target):
    "Get current device state and return it."

    try:
        devstatus = target.raw_query_device_status(timeout=5)
    except DeviceTimeoutError as e:
        raise IOError("No response received from device at address {0} (read {1} byte{2} before timeout)".format(
            target.address, len(e.read_so_far), '' if not e.read_so_far else 's'))

    return devstatus

def trace(level, msg, stream=sys.stderr, eol=True):
    global options
    if options.verbose >= level:
        stream.write(msg)
        if eol:
            stream.write('\n')
        else:
            stream.flush()

def report_on(device):
    print "Device Type:      {0} ({1} channels)".format(device.hardware_type, device.channels)
    print "Firmware Version: {0[0]}.{0[1]}".format(device.rom_version)

#class DeviceConfigurationError (Exception): pass

def change_speed(io, new_speed):
    trace(1, "Changing baud rate to {0}".format(new_speed))
    io.set_baud_rate(new_speed)
    time.sleep(1)

class InvalidFileFormat (Exception): pass
class MemoryImage (object):
    def __init__(self, limit=None):
        self.blocks = {}
        self.limit = limit

    def read_hex_file(self, filename):
        with open(filename) as hex_file:
            line_number = 0
            high_bits = 0
            at_EOF = False
            for record in hex_file:
                line_number += 1
                trace(2, '{1}, line {0}: {2}'.format(line_number, filename, record))

                record = record.strip()
                if record == '':
                    continue

                if at_EOF:
                    raise InvalidFileFormat('{1}, line {0}: Data after EOF record'.format(line_number, filename))

                #       0  1 2  3  4  5  6  7  ... -1
                #  ':' LL AAAA 00 <-- LL bytes --> CC     Data record
                #  ':' 00 0000 01                  FF     EOF 
                #  ':' 02 0000 02 XX Y0            CC     Subsequent addresses are 0XXY00+AAAA (not used here)
                #  ':' 04 0000 03 XX YY ZZ WW      CC     Not used by this program
                #  ':' 02 0000 04 XX YY            CC     Subsequent addresses are XXYYAAAA
                #  ':' 04 0000 05 XX YY ZZ WW      CC     Not used by this program

                if len(record) < 11 or record[0] != ':' or len(record) % 2 != 1:
                    raise InvalidFileFormat('{1}, line {0}: Invalid HEX File Line: {2}, len={3}'.format(line_number, filename, record, len(record)))

                try:
                    bytes = [int(record[i:i+2], 16) for i in range(1,len(record)-1,2)]
                except:
                    raise InvalidFileFormat('{1}, line {0}: Invalid hexadecimal value'.format(line_number, filename))

                if len(bytes) != bytes[0] + 4 + 1:
                    raise InvalidFileFormat('{1}, line {0}: Invalid record length {2}, should be {3}'.format(line_number, filename,
                        len(bytes), bytes[0] + 4 + 1))

                if reduce(lambda x,y: (x+y) & 0xff, bytes) != 0:
                    raise InvalidFileFormat('{1}, line {0}: Checksum mismatch.'.format(line_number, filename))

                if bytes[3] not in (0, 1, 4):
                    raise InvalidFileFormat('{1}, line {0}: Record type {2} not supported.'.format(line_number, filename, bytes[3]))

                if bytes[3] == 1:
                    if bytes[1] != 0 or bytes[2] != 0 or bytes[0] != 0:
                        raise InvalidFileFormat('{1}, line {0}: Invalid address or length field 0x{2:02X}{3:02X} [{4:02X}] for record type 01.'.format(line_number, filename, bytes[1], bytes[2], bytes[0]))
                    at_EOF = True

                elif bytes[3] == 4:
                    if bytes[1] != 0 or bytes[2] != 0 or bytes[0] != 2:
                        raise InvalidFileFormat('{1}, line {0}: Invalid address or length field 0x{2:02X}{3:02X} [{4:02X}] for record type 04.'.format(line_number, filename, bytes[1], bytes[2], bytes[0]))
                    high_bits = ((bytes[4] << 8) | bytes[5]) << 16
                    trace(1, "Addresses now at 0x{0:08X}".format(high_bits))

                elif bytes[3] == 0:
                    address = high_bits | (bytes[1] << 8) | bytes[2]
                    trace(1, "Adding {0} byte{1} of data starting at {2}".format(bytes[0], '' if bytes[0]==1 else 's', address))
                    for value in bytes[4:4+bytes[0]]:
                        block_ID    = address & 0xffffffc0
                        block_index = address & 0x0000003f
                        trace(3, "--> blk {0:08X} @ {1:08X} = {2:02X}".format(block_ID, address, value))

                        if address > self.limit:
                            trace(3, "Skipping write of {0:02X} -> {1:08X} (beyond our memory boundary)".format(
                                value, address))
                        else:
                            if block_ID not in self.blocks:
                                trace(4, "----> initialized new block")
                                self.blocks[block_ID] = [None] * 64

                            if self.blocks[block_ID][block_index] is not None:
                                raise InvalidFileFormat('{1}, line {0}: Address 0x{2:08X} overwritten with new value ({3:02X}->{4:02X})!'
                                    .format(line_number, filename, address, self.blocks[block_ID][block_index], value))

                            self.blocks[block_ID][block_index] = value
                        address += 1

        global options
        trace(4, "Memory image to burn:")
        if options.verbose >= 4:
            def format_hex(block):
                return ' '.join(['--' if i is None else "{0:02X}".format(i) for i in block])

            def format_ascii(block):
                return ''.join([(' ' if i is None else ('.' if (i<32 or i>126) else chr(i))) for i in block])

            for block_ID in sorted(self.blocks):
                # --------------------------------------------------------------------------------
                # XXXXXXXX: XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX  |................|
                #           XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX  |................|
                #           XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX  |................|
                #           XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX XX  |................|
                # ------------------------------------------------------------------------------
                d = self.blocks[block_ID]
                trace(4, "{0:08X}: {1}  |{2}|".format(block_ID, format_hex(d[00:16]), format_ascii(d[00:16])))
                trace(4, "          {1}  |{2}|".format(block_ID, format_hex(d[16:32]), format_ascii(d[16:32])))
                trace(4, "          {1}  |{2}|".format(block_ID, format_hex(d[32:48]), format_ascii(d[32:48])))
                trace(4, "          {1}  |{2}|".format(block_ID, format_hex(d[48:64]), format_ascii(d[48:64])))
                trace(4, "-"*78)



# pkt, cksum = encode_data(image_firmware.blocks[block_to_send], cksum)
# pkt = encode_byte(cksum)

def encode_byte(value):
    "encode a byte into simple ASCII encoding scheme, return 2-character encoded string."
    return (chr(0x40 | ((value >> 4) & 0x0f)) + chr(0x40 | (value & 0x0f)))

def encode_data(values, cksum):
    "encode list of bytes into ASCII string, update cksum; -> string, new cksum"
    pkt = []
    for v in values:
        if v is None:
            v = 0xff
        pkt.append(chr(0x40 | ((v >> 4) & 0x0f)))
        pkt.append(chr(0x40 | ( v       & 0x0f)))
        cksum = (cksum + v) & 0xff
    return ''.join(pkt), cksum

def encode_address(addr):
    "Convert integer address to four-character block number, return (encoded_string, checksum).  Exception raised if not aligned properly."
    if addr & 0x0003f:
        raise ValueError('address {0:05X} is not aligned on 64-byte block boundary'.format(addr))

    return (chr(0x40 | ((addr >> 16) & 0x0f)) + 
           chr(0x40 | ((addr >> 12) & 0x0f)) + 
           chr(0x40 | ((addr >>  8) & 0x0f)) + 
           chr(0x40 | ((addr >>  4) & 0x0c)),
           ((addr >> 12) & 0xff) + ((addr >>  4) & 0xfc))

def decode_address(encoded):
    "Convert four-character encoded address to integer start-of-block address"

    if len(encoded) != 4:
        raise ValueError('encoded address "{0}" is wrong length ({1} but expected 4)'.format(encoded, len(encoded)))
        
    if any([not 0x40 <= x <= 0x4f for x in encoded]):
        raise ValueError('encoded address "{0}" has invalid character(s)'.format(encoded))

    return ((ord(encoded[0] & 0x0f) << 16) | 
            (ord(encoded[1] & 0x0f) << 12) | 
            (ord(encoded[2] & 0x0f) <<  8) | 
            (ord(encoded[3] & 0x0f) <<  4))

class FlashProgrammingError (Exception): pass

def reflash(image_firmware, io):
    "Flash a new ROM image to the target device"
    #
    # Q -> */X
    # > page | 64bytes cks . -> n/!/y -> b/B -> v/V
    #
    # Do not print initial response; wait for query first.  ALL CMDS HAVE 1 RESPONSE
    #
    # Q -> XXXX*    Ready/OK
    #   -> XXXXn    Error in download format
    #   -> XXXX!    Invalid target address
    #   -> XXXXb    Erase/burn failed
    #   -> XXXXv    Verify failed
    #   
    #  X=last ID [OOOO if nothing received yet or block unknown]
    # >... -> same results as Q
    #
    # OOOO -> ffff ffff ffff ffff
    #         ffff ffff ffff ffff 0000
    #
    io.send('Q')
    response = io.input(bytes=5, timeout=10)
    if len(response) != 5:
        raise IOError('Failed to get expected response from device (expected 5 bytes, got {0}).'.format(len(response)))

    if response != 'OOOO*':
        raise FlashProgrammingError('Device not in expected starting state. ({0}) Reset and restart!'.format(response))

    for block_to_send in image_firmware.blocks:
        def flash_download(block_to_send):
            trace(2, "Downloading block {0:05X}".format(block_to_send))
            addr, cksum = encode_address(block_to_send)
            pkt = '>' + addr + '|'
            trace(3, "--Address:  {0}".format(pkt))
            io.send(pkt)
            pkt, cksum = encode_data(image_firmware.blocks[block_to_send], cksum)
            trace(3, "--Data:     {0}".format(pkt))
            io.send(pkt)
            pkt = encode_byte(cksum)
            trace(3, "--Checksum: {0}".format(pkt))
            io.send(pkt)
            io.send('.')

            response = io.input(bytes=5, timeout=10)

            if len(response) != 5 or response[4] not in '*n!bv':
                raise FlashProgrammingError('Out of sync with device or unexpected response (expected {0}x, received {1})'.format(
                    addr, response))

            if response[4] != '*':
                raise FlashProgrammingError('Flash update failure for block 0x{0:05X}: {1}'.format(
                    block_to_send, {
                        'n': 'Download format or checksum mismatch (communication error?)',
                        '!': 'Invalid target ROM address',
                        'b': 'FLASH burn operation failed',
                        'v': 'FLASH data verification failed'
                    }[response[4]]))
            if response[:4] != addr:
                raise FlashProgrammingError("Out of sync with device: expected {0}*, got {1}".format(addr, response))

        if block_to_send != 0:
            flash_download(block_to_send)
        flash_download(0)   # block 0 has to exist and has to be last

def yorn(prompt, defval=True):
    while True:
        ans = raw_input('{0} [{1}]? '.format(prompt, 'Y' if defval else 'N')).strip().lower()
        if ans.startswith('y'):
            return True
        if ans.startswith('n'):
            return False
        if ans == '':
            return defval
        print "Please answer 'y' or 'n'."

def main():
#    global status_cache, FACTORY_SETTINGS
    options, file_names, parser = parse_arguments()
    target, io = setup_lumos(options)

    if len(file_names) != 1:
        parser.error("Exactly one firmware image file must be specified.")

    if options.verbose > 2:
        io.set_verbose(sys.stderr)

    firmware_image = MemoryImage(limit=0x16fff)
    firmware_image.read_hex_file(file_names[0])
    if 0 not in firmware_image.blocks:
        raise InvalidFileFormat('Firmware image does not contain data for block #0')

    if not options.null_device:
        if not options.resume:
            status = target.raw_query_device_status(timeout=5)
            if status.hardware_type != 'lumos24dc':
                raise NotSupportedError('Board type {0} is not supported for this version of lumosupgrade.'
                    .format(status.hardware_type))
    
            report_on(status)
            if not status.in_config_mode:
                raise HardwareNotReady('Lumos board is not in configuration mode.')
        else:
            trace(0, "* Resuming interrupted upgrade (Lumos board must already be in program mode)")

        if not (options.force or yorn('Proceed to upgrade')):
            sys.exit(0)

        if not options.dry_run:
            if not options.resume:
                target.raw_begin_rom_download('CONFIRM','ROM','DOWNLOAD','YES','REALLY','I','MEAN','IT')
                trace(0, "* Waiting 10 seconds for device to reset *")
                time.sleep(5)
            else:
                trace(0, "* Waiting 5 seconds")

            change_speed(io, 9600)
            time.sleep(5)

            reflash(firmware_image, io)

            trace(0, "** Waiting 10 seconds for device to reset **")
            time.sleep(5)
            change_speed(io, options.speed)
            time.sleep(5)
            trace(0, "Checking current state of device")
            status = target.raw_query_device_status(timeout=5)
            report_on(status)

if __name__ == '__main__':
#    try:
        main()
#    except Exception as e:
#        sys.stderr.write("{0}: fatal error: {1}\n".format(sys.argv[0], e))
#        sys.exit(1)
