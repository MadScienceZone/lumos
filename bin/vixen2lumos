#!/usr/bin/env python
# vi:set ai sm nu ts=4 sw=4 expandtab:
#
# VIXEN SEQUENCE TO LUMOS SEQUENCE IMPORT UTILITY
# $Header: /tmp/cvsroot/lumos/bin/vixen2lumos,v 1.2 2008-12-30 22:58:02 steve Exp $
#
# Lumos Light Orchestration System
# Copyright Â© 2005, 2006, 2007, 2008 by Steven L. Willoughby, Aloha,
# Oregon, USA.  All Rights Reserved.  Licensed under the Open Software
# License version 3.0.
#
# This product is provided for educational, experimental or personal
# interest use, in accordance with the terms and conditions of the
# aforementioned license agreement, ON AN "AS IS" BASIS AND WITHOUT
# WARRANTY, EITHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION,
# THE WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A
# PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY OF THE ORIGINAL
# WORK IS WITH YOU.  (See the license agreement for full details, 
# including disclaimer of warranty and limitation of liability.)
#
# Under no curcumstances is this product intended to be used where the
# safety of any person, animal, or property depends upon, or is at
# risk of any kind from, the correct operation of this software or
# the hardware devices which it controls.
#
# USE THIS PRODUCT AT YOUR OWN RISK.
# 
import Lumos
from Lumos.Show                 import Show
from Lumos.Sequence             import Sequence
from Lumos.Event                import Event
from Lumos.Extras.VixenSequence import VixenSequence
from optparse                   import OptionParser
import sys
import csv
#@@REL@@sys.tracebacklimit=0

#========================================================================
# Command-line option processing
#========================================================================

parser = OptionParser(usage="%prog [-hIMvz] -c config [-i input] -m map [-o output]", 
  version='0.3a1', description='''
This command converts (at least basic/simple) Vixen sequence files
to Lumos sequence files.  This allows you to import your old sequences
if converting to Vixen, or to simply use Vixen to edit your sequences
and Lumos to play them back on your hardware/platform of choice.

To examine the Vixen file, perhaps to guide you in building
your channel map file:
  %prog --info --input=vixenfile

To have %prog build you the start of your channel map file
(which you will need to edit further before using):
  %prog --genmap=mapfile --input=vixenfile

To convert to Lumos (note you need a valid show config file AND
mapping file to show how channels are translated from Vixen to your
Lumos show setup):
  %prog [-vz] -c showconfig -i vixenfile -o lumosfile -m mapfile
  
''')

parser.add_option('-c', '--conf', metavar='FILE', help='Lumos show configuration file')
parser.add_option('-I', '--info', action='store_true', help='Print information about Vixen sequence and exit')
parser.add_option('-i', '--input', metavar='FILE', help='Input (Vixen sequence) [stdin]')
parser.add_option('-M', '--genmap', metavar='FILE', help='Create skeleton map file and exit')
parser.add_option('-m', '--map', metavar='FILE', help='Mapping of channels for sequence')
parser.add_option('-o', '--output', metavar='FILE', help='Output (Lumos sequence) [stdout]')
parser.add_option('-z', '--zero',    action='store_true', help='Force all channels off at start of sequence')
parser.add_option('-v', '--verbose', action='store_true', help='Enable more descriptive output')
(options, files) = parser.parse_args()

if len(files) > 0:
    parser.error("Extra arguments on command line.  (see --help)")

if not options.info and not options.genmap:
    if not options.conf:
        parser.error("You must specify a configuration file.  (see --help)")
    if not options.map:
        parser.error("You must specify a channel map file.  (see --help)")

if options.input:
    vixen_sequence_file = file(options.input, "r")
else:
    vixen_sequence_file = sys.stdin

if options.output:
    lumos_sequence_file =  file(options.output, "w")
else:
    lumos_sequence_file = sys.stdout

#show = Show()
#show.load_file(options.conf, open_device=False)


if options.verbose:
    print "Loading Vixen sequence from", vixen_sequence_file.name

vixen_data = VixenSequence()
vixen_data.load(vixen_sequence_file)

#########################################################################
# -I                                                                    #
# --info                                                                #
#           OUTPUT INFORMATION ABOUT VIXEN SEQUENCE AND THEN EXIT       #
#                                                                       #
#########################################################################
if options.info:
    print "Loaded sequence data from Vixen:"
    print "  Duration:    %02d:%02d.%03d" % (
        vixen_data.total_time/60000, 
        (vixen_data.total_time/1000) % 60, 
        vixen_data.total_time%1000
    )
    print "  Value Range: %d - %d" % (vixen_data.min_val, vixen_data.max_val)
    print "  Channels:    %d" % len(vixen_data.channels)
    for i, channel in enumerate(vixen_data.channels):
        print '  %3d = %-20s RGB=%02X%02X%02X out=%s' % (
            i, '"'+channel.name+'"', 
            channel.color[0],
            channel.color[1],
            channel.color[2],
            channel.output)
    sys.exit(0)

#########################################################################
# -M                                                                    #
# --genmap                                                              #
#           OUTPUT STUB FOR CHANEL MAP FILE AND THEN EXIT               #
#                                                                       #
#########################################################################
if options.genmap:
    if options.verbose:
        print "Writing stub channel mapping to", options.genmap

    map_writer = csv.writer(file(options.genmap, 'w'))
    map_writer.writerows((
("#",),
("# Lumos Channel Map",),
("#",),
("# This maps Vixen sequence file channels to Lumos sequence file channels.  ",),
("# This is in standard CSV format.  Fields containing commas need to be",),
("# surrounded by double quotes (although any field may be).  If the first",),
("# field on a line begins with a pound sign (#)"," then that line is ignored",),
("# as a comment.",),
("#",),
("# The fields are:",),
("#    INDEX","NAME","CONTROLLER","CHANNEL",),
("#",),
("# INDEX       is an integer value specifying the channel index number","",),
("#             where the first channel appearing in the Vixen file is",),
("#             number 0"," the next is number 1"," etc.",),
("#",),
("# NAME        is the name associated with the channel in Vixen"," which",),
("#             is displayed on the grid for that channel.",),
("#",),
("# CONTROLLER  is the name defined in the show configuration file for",),
("#             the Lumos controller which will be assigned to this",),
("#             channel.",),
("#",),
("# CHANNEL     is the name of the channel controlled by CONTROLLER.",),
("#",),
("# You may specify either INDEX or NAME (or both)"," but note that if ",),
("# you leave one out the field is left empty:",),
("#     12","","",),
("#",),
("# The first field is either 'index' or 'name'"," and specifies whether",),
("# you are mapping Vixen channels by index number (i.e."," numbered ",),
("# sequentially from zero in the order they appear in the Vixen file"," ",),
("# which is the number shown in the output of 'vixen2lumos --info'):",),
("#      index","3","...",),
("# or whether you are mapping channels by the text name displayed by",),
("# Vixen for the channel:",),
("#      name","Red Tree #12","...",),
("#",),
("# In either case"," the next two fields give the controller name and channel",),
("# as defined in the Lumos show configuration file.  For example"," in the",),
("# following mapping file"," The first three Vixen channels map to channel",),
("# number 1"," 3"," and 12 of controller 'fg1' respectively:",),
("#       index","0","fg1","1",),
("#       index","1","fg1","3",),
("#       index","2","fg1","12",),
("# while in this one"," the Vixen channel for red"," green and blue flood",),
("# lights are mapped to X-10 channels in house code C on the controller ",),
("# called 'xfloods':",),
("#       name","red floodlights","xfloods","c5",),
("#       name","green floodlights","xfloods","c6",),
("#       name","blue floodlights","xfloods","c7",),
("#",),
("# Spaces should *not* be added around the commas or before or after the",),
("# data on the line.",),
("#",),
))
    for i, channel in enumerate(vixen_data.channels):
        map_writer.writerow((i, channel.name, 'CONTROLLER', 'CHANNEL'))
    sys.exit(0)

#########################################################################
# -c                                                                    #
# --conf                                                                #
#           LOAD SHOW CONFIGURATION                                     #
#                                                                       #
#########################################################################

show = Show()
show.load_file(options.conf, open_device=False)

#########################################################################
# -m                                                                    #
# --map                                                                 #
#           LOAD MAP FILE INTO MEMORY                                   #
#                                                                       #
#########################################################################
if options.verbose:
    print "Loading channel map from", options.map

# channel_map references a (device,channel) tuple by Vixen index
# or None if not mapped.
channel_map = [None for i in range(len(vixen_data.channels))]
mapped_channels = {}

try:
    for mapping in csv.reader(file(options.map)):
        if mapping[0].startswith('#'):
            continue
        #
        # If they specified an index, just use that.
        #
        if mapping[0] != '':
            try:
                idx = int(mapping[0])
            except:
                raise ValueError("channel map index (first field) must be an integer")

            if mapping[1] != '':
                if mapping[1] != vixen_data.channels[idx].name:
                    raise ValueError('Vixen channel #%d is called "%s", not "%s"' % (
                        idx, vixen_data.channels[idx].name, mapping[1]))
        #
        # If they just gave a name, look it up
        #
        elif mapping[1] != '':
            try:
                idx = [i.name for i in vixen_data.channels].index(mapping[1])
            except:
                raise ValueError('Vixen channel name "%s" not found in sequence file.' % mapping[1])
        #
        # But they need at least one of the two!
        #
        else:
            raise ValueError('Each mapping needs at least an index number or channel name!')
        #
        # At this point, we have our target index in idx.  As long as that hasn't
        # already been mapped to something, we're good to go.
        #
        if not 0 <= idx < len(channel_map):
            raise ValueError("channel map index value %d out of bounds (0-%d)" % (idx, len(channel_map)-1))

        if channel_map[idx] is not None:
            raise ValueError('channel map for Vixen #%d ("%s") mapped more than once!' % (idx, 
                vixen_data.channels[idx].name))
        #
        # Of course, now we need to make sure what it maps TO is valid...
        #
        if mapping[2] not in show.controllers:
            raise ValueError('No such controller "%s" to which to map channel #%d ("%s")' % (
                mapping[2], idx, vixen_data.channels[idx].name))

        target_controller = show.controllers[mapping[2]]
        try:
            target_channel = target_controller.channel_id_from_string(mapping[3])
        except Exception, e:
            raise ValueError('Invalid channel "%s" for controller "%s" (%s)' % (
                mapping[3], mapping[2], e))
        #
        # Any funny business?
        #
        try:
            assert(target_controller.channels[target_channel] is not None)
        except:
            raise ValueError('Vixen channel #%d ("%s") maps to Lumos channel %s.%s, but that channel is not configured in the show configuration!' % (idx, vixen_data.channels[idx].name, mapping[2], target_channel))

        if target_channel in mapped_channels.setdefault(target_controller.id, []):
            print >> sys.stderr, """
WARNING: ******************************************************************
WARNING: * MULTIPLE VIXEN CHANNELS MAP TO LUMOS CHANNEL %s.%s!
WARNING: * (This is allowed, and will be permitted here, but it is likely
WARNING: * not what was intended.  You are advised to double-check your
WARNING: * channel map file before using this imported sequence!)
WARNING: ******************************************************************
""" % (target_controller.id, target_channel)
        else:
            mapped_channels[target_controller.id].append(target_channel)

        #
        # Everything checks out, make it so...
        #
        channel_map[idx] = (target_controller, target_channel)
except Exception, e:
    print >>sys.stderr, "Unable to read mapping file: %s" % e
    sys.exit(1)

if options.verbose:
    print "Channel mapping:"
    print " VIXEN CHANNEL ID/NAME          ->          LUMOS CONTROLLER CHANNEL"
    for i, mapping in enumerate(channel_map):
        print " # %2d %-25s -> %25s %3s" %(
           i, vixen_data.channels[i].name,
           mapping[0].id, mapping[1])

#
# Having done that, verify that we mapped everything.
# it's not an error to leave something out, but it may
# be a sign of a problem, particularly if a Vixen channel
# is being left out.
#
for i, channel in enumerate(vixen_data.channels):
    if channel_map[i] is None:
        print >> sys.stderr, 'WARNING: Vixen channel #%d ("%s") NOT MAPPED TO ANY Lumos controller!' % (
            i, vixen_data.channels[i].name)
for c_id in show.controllers:
    if c_id not in mapped_channels:
        print >> sys.stderr, 'WARNING: Lumos controller "%s" not mapped from any Vixen channel.' % c_id
        continue
    for channel in show.controllers[c_id].iter_channels():
        if channel not in mapped_channels[c_id]:
            print >> sys.stderr, 'WARNING: Lumos channel "%s.%s" not mapped from any Vixen channel.' %(
                c_id, channel)
#
# Build a Lumos sequence from the data we just imported.
#
if options.verbose:
    print "Generating Lumos sequence data"

lumos_data = Sequence()

if options.zero:
    lumos_data.add(0, Event(None, None, 0, 0))

for vixen_event in vixen_data.events:
    lumos_data.add(vixen_event[0], Event(*(channel_map[vixen_event[1]] + 
        (((vixen_event[2] - vixen_data.min_val) * 100.0) / (vixen_data.max_val - vixen_data.min_val) , 0))))
#
# ...and write it out...
#
if options.verbose:
    print "Writing Lumos sequence to", lumos_sequence_file.name
lumos_data.save(lumos_sequence_file)

#
# $Log: not supported by cvs2svn $
#
