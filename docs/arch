UI sees sequences as set of (t,c,ch,v) events with normalized value like
real percentages or 0-255
	sequence event types:
		on
		off
		all off
		kill
		all kill
		level(n)
		fade(start,end,interval)
		*repeats?
		*subsequences?
		*background tracks?
	
Sequence builder looks at devices, resolutions, etc to build event list
for playback, something like (t,c,ch,rawval) or even (t,net,bytes)


EventType objects?
	
	set value to n over time delta t
		that pretty much sums it all up for light controllers, not for
		other things like readerboards, but we still have to figure out
		how those work with Lumos anyway.
	

sequence:
	list of timed events:
		(time, controller, channel, value)
		(ms, controller_obj, method_obj, arglist)

controller (ControllerUnit class):
	sends events to network

	default
		ids are strings (index into channels dict)

	FireGodControllerUnit
		ids are integer indexes into channels list
	X10ControllerUnit
		ids are in form "A1".."P16"
	   FirecrackerX10ControllerUnit
	 	packet(id, op) -> bytes to send to device
	   LynX10ControllerUnit
	LumosControllerUnit(id, power_source, network, address=0, resolution=256, num_channels=48)
		throws {DeviceProtocol,InternalDevice,Internal}Error
		ids are integer indexes into channels list
		.dumpstats(filename)
		.raw_ramp_up(ch, steps, delay, cycle=False)
		.raw_ramp_down(ch, steps, delay, cycle=False)
		.raw_control(cmd_name, ...)
			'sleep'
			'wake'
			'shutdown'
			'execute', a[]
			'masksens', a[]
			'clearmem'
			'noconfig'
			'xconfig'
			'forbid'
			'__reset__'
			'__baud__', speedcode[]
		.raw_begin_rom_download(...)
		.raw_set_phase(v)
		.raw_set_address(a)
		.raw_download_sequence(id, bits)
		.raw_sensor_trigger(sensor, pre, seq, post, inverse=False, execf=False)
		.raw_configure_device(conf_obj)
		.raw_query_device_status(timeout=0) -> LumosControllerStatus
		.__str__() -> string representation 
		.channel_id_from_string(channel) -> int channel
		.add_channel(id, name=None, load=None, dimmer=True, warm=None, resolution=None, power_source=None)
		.flush(force=False)	send pending channel level setting commands optimally
		.set_channel(id, level, force=False)
		.set_channel_on(id, force=False)
		.set_channel_off(id, force=False)
		.kill_channel(id, force=False)
		.kill_all_channels(force=False)
		.initialize_device()
	  QuizShowConsole(same parameters as LumosControllerUnit)
?	   	.raw_start_scanning()
?		.raw_set_button_masks()
?		.raw_display_text(message)
?		.raw_display_bitmap(image)
?		.raw_set_qs_parameters(lockout_cycles=0)
?		.raw_qs_query(level=FULL_QUERY, stop_scanning=False, timeout=0)
		protocol_debugger(data, fileobj)
	    QuizShowMainController
	      QuizShowStatus
	        QuizShowMainControllerStatus
			.buttons{x8, l8, x9, l9, ... l15: QuizShowButtonStatus obj}
	      	

 	    QSProtocol* classes are used to describe (to a text file) what a command stream means
	    QSProtocol(data: bytes, fileobj)
	    	.require(bytes_needed: int)	make sure we have that many bytes (resolves escapes)
		.interpret()			interprets collected command if we have a complete one by creating a QSProtocol* and calling interpret()
		.next()				move on to next command
	    QuizShowButtonStatus
	    	.masked:   bool
		.pressed:  bool
		.time:     ÂµS
		.name:     str
		.is_locked_out()-> bool  (unimplemented)
		.is_pressed()->    bool  (!masked pressed)
		.is_masked()->     bool  (masked)
		.is_unanswered()-> bool  (!masked !pressed)
	    QuizShowStatus(ping_time=0)
	    	.last_contact:     time
		.scanner_running:  bool
		.buttons:          dict{button_name: QuizShowButtonStatus_obj}
		.any_buttons_pressed() -> bool


	    
	LumosLegacyControllerUnit
		(for units with 2.x ROMs)
	Olsen595ControllerUnit
	RenardControllerUnit
	SpectrumReaderboardUnit
		throws InvalidTextAlignment, InvalidTextMode, InvalidTextAttribute
	UltraDMXMicroControllerUnit
		throws DeviceProtocolError
	 	

	__init__(id, power_source, network, [resolution=100], ...)
		FireGodControllerUnit:	+address=1, num_channels=32
		LumosControllerUnit:	+address=0, num_channels=48
		LumosLegacyControllerUnit: +address
		Olsen595ControllerUnit:	+num_channels=64
		RenardControllerUnit:	+address=0, num_channels=64
		UltraDMXMicroControllerUnit: +num_channels=512
	channel_id_from_string(channel)	# channel name -> id
		FireGodControllerUnit:	-> int
	add_channel(id, [name], [load], [dimmer=True], [warm], [resolution], [power_source])
	set_channel(id, level, [force=False])
		id can be string or int depending on type of unit
		level is number (int? float? %? raw?) or None
			None: turn completely off as opposed to dim down to 0%
	set_channel_on(id, [force=False])
	set_channel_off(id, [force=False])
	kill_channel(id, [force=False])
		kill is like off but ignores warm setting
	kill_all_channels([force=False])
	all_channels_off([force=False])
	initialize_device()
	flush([force=False])
		calls network.send with the binary data
	iter_channels()			# iterates over channel IDs
	_iter_non_null_channel_list()	# only includes implemented channels
	current_drain()			# -> {chan_id: (amps, PowerSource), ...}
	current_loads()			# -> {chan_id: (amps, PowerSource), ...}
	__str__()			# human readable description of controller

channel:
	__init__(id, [name], [load], [dimmer], [warm], [resolution])
	raw_dimmer_value(pct) -> nn   (None->0)
	pct_dimmer_value(nn) -> pct   (None->0)
	normalized_value(pct, [override]) -> pct' (adjusted for warm limit)
	set_level(newlevel, [override]) -> (oldraw, newraw)
		enforces warm, max/min limits
	set_on()
	set_off()
	kill()
		
