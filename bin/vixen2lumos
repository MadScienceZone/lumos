#!/usr/bin/env python
# vi:set ai sm nu ts=4 sw=4 expandtab:
#
# VIXEN SEQUENCE TO LUMOS SEQUENCE IMPORT UTILITY
#
# Lumos Light Orchestration System
# Copyright (c) 2005, 2006, 2007, 2008, 2014, 2016 by Steven L. Willoughby, Aloha,
# Oregon, USA.  All Rights Reserved.  Licensed under the Open Software
# License version 3.0.
#
# This product is provided for educational, experimental or personal
# interest use, in accordance with the terms and conditions of the
# aforementioned license agreement, ON AN "AS IS" BASIS AND WITHOUT
# WARRANTY, EITHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION,
# THE WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A
# PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY OF THE ORIGINAL
# WORK IS WITH YOU.  (See the license agreement for full details, 
# including disclaimer of warranty and limitation of liability.)
#
# Under no curcumstances is this product intended to be used where the
# safety of any person, animal, or property depends upon, or is at
# risk of any kind from, the correct operation of this software or
# the hardware devices which it controls.
#
# USE THIS PRODUCT AT YOUR OWN RISK.
# 
import Lumos
from Lumos.Show                 import Show
from Lumos.Sequence             import Sequence, AudioTrack
from Lumos.Event                import Event
from Lumos.Extras.VixenSequence import VixenSequence
from optparse                   import OptionParser
import sys
import csv
#@@REL@@sys.tracebacklimit=0

#========================================================================
# Command-line option processing
#========================================================================

parser = OptionParser(usage="%prog [-hIMvz] -c config [-i input] -m map [-o output]", 
  version='@@RELEASE@@', description='''
This command converts (at least basic/simple) Vixen sequence files
to Lumos sequence files.  This allows you to import your old sequences
if converting to Vixen, or to simply use Vixen to edit your sequences
and Lumos to play them back on your hardware/platform of choice.

To examine the Vixen file, perhaps to guide you in building
your channel map file:
  %prog --info --input=vixenfile

To have %prog build you the start of your channel map file
(which you will need to edit further before using):
  %prog --genmap=mapfile --input=vixenfile

To convert to Lumos (note you need a valid show config file AND
mapping file to show how channels are translated from Vixen to your
Lumos show setup):
  %prog [-vz] -c showconfig -i vixenfile -o lumosfile -m mapfile
  
''')

parser.add_option('-c', '--conf', metavar='FILE', help='Lumos show configuration file')
parser.add_option('-I', '--info', action='store_true', help='Print information about Vixen sequence and exit')
parser.add_option('-i', '--input', metavar='FILE', help='Input (Vixen sequence) [stdin]')
parser.add_option('-M', '--genmap', metavar='FILE', help='Create skeleton map file and exit')
parser.add_option('-m', '--map', metavar='FILE', help='Mapping of channels for sequence')
parser.add_option('-o', '--output', metavar='FILE', help='Output (Lumos sequence) [stdout]')
parser.add_option('-z', '--zero',    action='store_true', help='Force all channels off at start of sequence')
parser.add_option('-v', '--verbose', action='store_true', help='Enable more descriptive output')
(options, files) = parser.parse_args()

if len(files) > 0:
    parser.error("Extra arguments on command line.  (see --help)")

if not options.info and not options.genmap:
    if not options.conf:
        parser.error("You must specify a configuration file.  (see --help)")
    if not options.map:
        parser.error("You must specify a channel map file.  (see --help)")

if options.input:
    vixen_sequence_file = file(options.input, "r")
else:
    vixen_sequence_file = sys.stdin

if options.output:
    lumos_sequence_file =  file(options.output, "w")
else:
    lumos_sequence_file = sys.stdout

#show = Show()
#show.load_file(options.conf, open_device=False)


if options.verbose:
    print "Loading Vixen sequence from", vixen_sequence_file.name

vixen_data = VixenSequence()
vixen_data.load(vixen_sequence_file)

#########################################################################
# -I                                                                    #
# --info                                                                #
#           OUTPUT INFORMATION ABOUT VIXEN SEQUENCE AND THEN EXIT       #
#                                                                       #
#########################################################################
if options.info:
    print "Loaded sequence data from Vixen:"
    print "  Duration:    %02d:%02d.%03d" % (
        vixen_data.total_time/60000, 
        (vixen_data.total_time/1000) % 60, 
        vixen_data.total_time%1000
    )
    print "  Value Range: %d - %d" % (vixen_data.min_val, vixen_data.max_val)
    print "  Channels:    %d" % len(vixen_data.channels)
    for i, channel in enumerate(vixen_data.channels):
        print '  %3d = %-20s RGB=%02X%02X%02X out=%s' % (
            i, '"'+channel.name+'"', 
            channel.color[0],
            channel.color[1],
            channel.color[2],
            channel.output)
    if vixen_data.audio_filename is not None:
        print '  Audio:   "%s"' % vixen_data.audio_filename

    sys.exit(0)

#########################################################################
# -M                                                                    #
# --genmap                                                              #
#           OUTPUT STUB FOR CHANEL MAP FILE AND THEN EXIT               #
#                                                                       #
#########################################################################
if options.genmap:
    if options.verbose:
        print "Writing stub channel mapping to", options.genmap

    map_writer = csv.writer(file(options.genmap, 'w'))
    map_writer.writerows((
("#",),
("# Lumos Channel Map",),
("#",),
("# This maps Vixen sequence file channels to Lumos sequence file channels.  ",),
("# This is in standard CSV format.  Fields containing commas need to be",),
("# surrounded by double quotes (although any field may be).  If the first",),
("# field on a line begins with a pound sign (#)"," then that line is ignored",),
("# as a comment.",),
("#",),
("# Channel map file version 2",),
("CMV","2"),
("#",),
("# The fields are:",),
#("#    INDEX","NAME","CONTROLLER","CHANNEL",),
#("#",),
("#    INDEX","NAME","V_CHANNEL","[SUBCHANNEL]"),
("#",),
("# INDEX       is an integer value specifying the channel index number","",),
("#             where the first channel appearing in the Vixen file is",),
("#             number 0"," the next is number 1"," etc.",),
("#",),
("# NAME        is the name associated with the channel in Vixen"," which",),
("#             is displayed on the grid for that channel.",),
("#",),
#("# CONTROLLER  is the name defined in the show configuration file for",),
#("#             the Lumos controller which will be assigned to this",),
#("#             channel.",),
#("#",),
#("# CHANNEL     is the name of the channel controlled by CONTROLLER.",),
#("#",),
("# V_CHANNEL   is the ID of the virtual channel as defined in the show",),
("#             configuration file for this Vixen channel.",),
("#",),
("# SUBCHANNEL  is, for complex devices such as RGB channels, the sub-component",),
("#             number of the virtual channel to use for this Vixen channel.",),
("#             regular toggles and dimmers should not specify this field at all.",),
("#",),
("# You may specify either INDEX or NAME (or both)"," but note that if ",),
("# you leave one out the field is left empty:",),
("#     12","","",),
("#",),
("# The first field is either 'index' or 'name'"," and specifies whether",),
("# you are mapping Vixen channels by index number (i.e."," numbered ",),
("# sequentially from zero in the order they appear in the Vixen file"," ",),
("# which is the number shown in the output of 'vixen2lumos --info'):",),
("#      index","3","...",),
("# or whether you are mapping channels by the text name displayed by",),
("# Vixen for the channel:",),
("#      name","Red Tree #12","...",),
("#",),
#("# In either case"," the next two fields give the controller name and channel",),
("# In either case"," the next field gives the virtual channel ID",),
("# as defined in the Lumos show configuration file.  For example"," in the",),
("# following mapping file"," The first three Vixen channels map to channels",),
#("# number 1"," 3"," and 12 of controller 'fg1' respectively:",),
#("#       index","0","fg1","1",),
#("#       index","1","fg1","3",),
#("#       index","2","fg1","12",),
("# fg1"," fg2"," and fg3, respectively:",),
("#       0","","fg1"),
("#       1","","fg2"),
("#       2","","fg3"),
#("# while in this one"," the Vixen channel for red"," green and blue flood",),
#("# lights are mapped to X-10 channels in house code C on the controller ",),
#("# called 'xfloods':",),
#("#       name","red floodlights","xfloods","c5",),
#("#       name","green floodlights","xfloods","c6",),
#("#       name","blue floodlights","xfloods","c7",),
("# while in this one"," the Vixen channel for red"," green and blue flood",),
("# lights are mapped to a single RGB virtual channel called colorflood:",),
("#        ","red floodlights","colorflood","0"),
("#        ","green floodlights","colorflood","1"),
("#        ","blue floodlights","colorflood","2"),
("#",),
("# Spaces should *not* be added around the commas or before or after the",),
("# data on the line.",),
("#",),
))
    for i, channel in enumerate(vixen_data.channels):
        map_writer.writerow((i, channel.name, 'V_CHANNEL'))
    sys.exit(0)

#########################################################################
# -c                                                                    #
# --conf                                                                #
#           LOAD SHOW CONFIGURATION                                     #
#                                                                       #
#########################################################################

show = Show()
show.load_file(options.conf.split(','), open_device=False)

#########################################################################
# -m                                                                    #
# --map                                                                 #
#           LOAD MAP FILE INTO MEMORY                                   #
#                                                                       #
#########################################################################
if options.verbose:
    print "Loading channel map from", options.map

# channel_map references a (device,channel) tuple by Vixen index
# or None if not mapped.
channel_map = [None for i in range(len(vixen_data.channels))]
hw_to_virtual_map = None
mapped_channels = {}
mapped_virtual_channels = set()
file_format = None

try:
    for mapping in csv.reader(file(options.map)):
        if mapping[0].startswith('#'):
            continue

        if mapping[0] == "CMV":
            if file_format is not None:
                raise ValueError("channel map version record CMV must be first non-comment record!")
            if mapping[1] == "1":
                file_format = 1
            elif mapping[1] == "2":
                file_format = 2
            else:
                raise ValueError("File format version {0} is not supported.".format(mapping[1]))
            continue

        if file_format is None:
            file_format = 1

        #
        # If they specified an index, just use that.
        #
        if mapping[0] != '':
            try:
                idx = int(mapping[0])
            except:
                raise ValueError("channel map index (first field) must be an integer")

            if mapping[1] != '':
                if mapping[1] != vixen_data.channels[idx].name:
                    raise ValueError('Vixen channel #%d is called "%s", not "%s"' % (
                        idx, vixen_data.channels[idx].name, mapping[1]))
        #
        # If they just gave a name, look it up
        #
        elif mapping[1] != '':
            try:
                idx = [i.name for i in vixen_data.channels].index(mapping[1])
            except ValueError:
                raise ValueError('Vixen channel name "%s" not found in sequence file.' % mapping[1])
        #
        # But they need at least one of the two!
        #
        else:
            raise ValueError('Each mapping needs at least an index number or channel name!')
        #
        # At this point, we have our target index in idx.  As long as that hasn't
        # already been mapped to something, we're good to go.
        #
        if not 0 <= idx < len(channel_map):
            raise ValueError("channel map index value %d out of bounds (0-%d)" % (idx, len(channel_map)-1))

        if channel_map[idx] is not None:
            raise ValueError('channel map for Vixen #%d ("%s") mapped more than once!' % (idx, 
                vixen_data.channels[idx].name))
        #
        # Of course, now we need to make sure what it maps TO is valid...
        #
        if file_format == 1:
            #
            # legacy file format:   [idx],[name],controller,channel
            #
            if mapping[2] not in show.controllers:
                raise ValueError('No such controller "{0}" to which to map channel #{1} ("{2}")'.format(
                    mapping[2], idx, vixen_data.channels[idx].name))
            target_controller = show.controllers[mapping[2]]
            try:
                target_channel = target_controller.channel_id_from_string(mapping[3])
            except Exception as e:
                raise ValueError('Invalid channel "{0}" for controller "{1}" ({2})'.format(
                    mapping[3], mapping[2], e))
            #
            # turn target_controller, target_channel to a virtual channel and subchannel
            #
            if hw_to_virtual_map is None:
                # build a map of "id(controller_object).channel_ID" -> (virtual_obj_id,sub#)
                hw_to_virtual_map = {}
                for vchannel_ID, vchannel_obj in show.virtual_channels.items():
                    clist = vchannel_obj.channel
                    if not isinstance(clist, (list, tuple)):
                        clist = [clist]
                    for sub_idx, hw_channel in enumerate(clist):
                        key = "{0}.{1}".format(id(hw_channel.controller), hw_channel.id)
                        if key in hw_to_virtual_map:
                            raise KeyError("Show defines overlapping virtual channels!  We see multiple definitions for {0}".format(hw_channel.controller.id))
                        hw_to_virtual_map[key] = (vchannel_ID, sub_idx)

            #
            # Any funny business?
            #
            try:
                assert(target_controller.channels[target_channel] is not None)
            except:
                raise ValueError('Vixen channel #%d ("%s") maps to Lumos channel %s.%s, but that channel is not configured in the show configuration!' % (idx, vixen_data.channels[idx].name, mapping[2], target_channel))

            if target_channel in mapped_channels.setdefault(target_controller.id, []):
                print >> sys.stderr, """
WARNING: ******************************************************************
WARNING: * MULTIPLE VIXEN CHANNELS MAP TO HARDWARE CHANNEL %s.%s!
WARNING: * (This is allowed, and will be permitted here, but it is likely
WARNING: * not what was intended.  You are advised to double-check your
WARNING: * channel map file before using this imported sequence!)
WARNING: ******************************************************************
""" % (target_controller.id, target_channel)
            else:
                mapped_channels[target_controller.id].append(target_channel)

            target_vchannel = hw_to_virtual_map["{0}.{1}".format(id(target_controller), target_channel)]
        elif file_format == 2:
            #
            # current file format:  [idx],[name],virtual_channel_ID,[subchannel]
            #
            if mapping[2] not in show.virtual_channels:
                raise ValueError('Virtual channel "{0}" not found in this show'.format(mapping[2]))

            if len(mapping) >= 4:
                try:
                    subidx = int(mapping[3])
                except ValueError:
                    raise ValueError('Sub-channel index must be an integer, not "{0}"'.format(mapping[3]))
            else:
                subidx = 0

            target_vchannel = (mapping[2], subidx)
            #
            # Any funny business?
            #
            key = "{0}#{1}".format(mapping[2], subidx)
            if key in mapped_virtual_channels:
                print >> sys.stderr, """
WARNING: ******************************************************************
WARNING: * MULTIPLE VIXEN CHANNELS MAP TO VIRTUAL CHANNEL {0}!
WARNING: * (This is allowed, and will be permitted here, but it is likely
WARNING: * not what was intended.  You are advised to double-check your
WARNING: * channel map file before using this imported sequence!)
WARNING: ******************************************************************
""".format(mapping[2])
            else:
                mapped_virtual_channels.add(key)
        else:
            raise NotImplementedError("Support for file format {0} not implemented (this really shouldn't happen--probably a bug!".format(file_format))

        #
        # Now we know this vixen channel (idx) goes to virtual channel target_vchannel
        # which is a tuple of (vchan_id, sub#).
        #

        #
        # Everything checks out, make it so...
        #
        channel_map[idx] = target_vchannel
except Exception, e:
    print >>sys.stderr, "Unable to read mapping file: %s" % e
    sys.exit(1)

if options.verbose:
# VIXEN CHANNEL ID/NAME     -> LUMOS VIRTUAL CHANNEL -> LUMOS HARDWARE CHANNEL
# <3> <-----------24---------> <---------22--------->   <----------21-------> <3>
# 999 ZZZZZZZZZZZZZZZZZZZZZZZZ ZZZZZZZZZZZZZZZZZZZZZZ 9 ZZZZZZZZZZZZZZZZZZZZZ 999
    print "Channel mapping:"
    print "VIXEN CHANNEL ID/NAME     -> LUMOS VIRTUAL CHANNEL -> LUMOS HARDWARE CHANNEL"
    for i, mapping in enumerate(channel_map):
        if mapping is None:
            print "{0:3d} {1:24.24s} <Not Mapped>".format(i, vixen_data.channels[i].name)
        else:
            hw = show.virtual_channels[mapping[0]].all_hardware_channels()[mapping[1]]
            print "{0:3d} {1:24.24s} {2:22.22s} {3} {4:21.21s} {5:>3s}".format(
                i, vixen_data.channels[i].name, mapping[0], mapping[1],
                hw.controller.id, hw.id)

#
# Having done that, verify that we mapped everything.
# it's not an error to leave something out, but it may
# be a sign of a problem, particularly if a Vixen channel
# is being left out.
#
for i, channel in enumerate(vixen_data.channels):
    if channel_map[i] is None:
        print >> sys.stderr, 'WARNING: Vixen channel #%d ("%s") NOT MAPPED TO ANY Lumos controller!' % (
            i, vixen_data.channels[i].name)

#
# Build a Lumos sequence from the data we just imported.
#
if options.verbose:
    print "Generating Lumos sequence data"

lumos_data = Sequence()

if vixen_data.audio_filename is not None:
    if options.verbose:
        print 'Adding audio track information ("%s")' % vixen_data.audio_filename

    lumos_data.audio = AudioTrack(vixen_data.audio_filename)

if options.zero:
    lumos_data.add(0, ValueEvent(None, 0, 0))

dropped_events = 0
for vixen_event in vixen_data.events:
    if channel_map[vixen_event[1]] is None:
        dropped_events += 1
        continue

    vchannel = show.virtual_channels[channel_map[vixen_event[1]][0]]
    vchannel.set_raw_value(((vixen_event[2] - vixen_data.min_val) * 100.0) / (vixen_data.max_val - vixen_data.min_val), channel_map[vixen_event[1]][1])
    lumos_data.add(vixen_event[0], ValueEvent(vchannel, vchannel.denormalize_level_value(vchannel.current_raw_value), 0))
    
#
# ...and write it out...
#
if options.verbose:
    print "Writing Lumos sequence to", lumos_sequence_file.name
lumos_data.save(lumos_sequence_file)

if dropped_events:
    print >>sys.stderr, "WARNING: Dropped %d event%s due to unmapped source channels!" % (
        dropped_events, "s" if dropped_events != 1 else "")
