.TH LUMOS-CONTROLLER 4 "Lumos" "Software Alchemy" "Device Drivers"
.SH NAME
lumos-controller \- Lumos controller device driver implementation notes
.SH DESCRIPTION
.LP
The Lumos light circuit sequencing program was designed to be extended for
use with arbitrary controller hardware by \*(lqplugging in\*(rq device drivers 
for new types of controllers.  This document describes the general design
of Lumos' driver system and how one would go about writing a new driver
for Lumos.
.LP
The Lumos program is implemented in Python, and the device drivers are simply
Python modules which each define an object class describing a particular type
of hardware controller.  
.SS "Theory of Operation"
.LP
Each device driver class describes a certain kind of hardware device.
The main application software will create an instance of each driver class
for each controller described in the 
.B show.conf
file, and will then call the
.B add_channel()
method in each, to set up the active channels used in the show.  (Your device
driver should not depend on all physical channels being constructed, nor
should it assume that unused channels
.I won't
be.)  Finally, as a last step before the show sequences begin, the driver's
.B initialize_device()
method is called.
.LP
During the operation of the show, various channel manipulation methods
(such as
.BR set_channel() )
are called to make changes in each device's outputs.  These methods 
can invoke the 
.B _send_to_device()
method to pass the appropriate command codes to the hardware.
Some kinds of controllers might choose to buffer up several state changes 
before actually transmitting command bytes.  For example, a device requiring 
all channel data to be sent for each update (e.g., the \*(lqOlson 595\*(rq),
may not actually send anything to the network yet.  When all the changes for a 
given time event are set, Lumos will call the 
.B flush()
method in each controller.  This will allow those controllers to know it's
time to send their bulk update data to the device.
.LP
No device is expected to ever send data back to Lumos; these drivers are 
write-only.
.SS "Definition of the Controller Class"
.LP
Each controller driver is a separate module (and therefore stored in its own 
file).  To start a new controller, create a file with an appropriate name
such as 
.RB \*(lq WhizzoLightController.py \*(rq.
.LP
All controller driver classes are subclasses of 
.BR ControllerUnit ,
which is an abstract base class describing the essential attributes and 
behaviors of all controller types.  If you haven't already done so, look
over the documentation for that module (the simplest way is to type the
command
.RB \*(lq "pydoc ControllerUnit" \*(rq
from inside the Lumos source directory (or from anywhere if you have that directory in your 
.BR PYTHONPATH .)
.LP
Note also that where there are some general groupings of similar kinds of 
controllers, intermediate classes have been created.  Thus, while 
.B SSR48Controller
is a direct subclass of 
.BR ControllerUnit ,
.B FirecrackerX10ControllerUnit
and 
.B LynX10ControllerUnit
are subclasses of
.BR X10ControllerUnit ,
which is itself a subclass of
.BR ControllerUnit .
In this way, all the general X-10 controller behavior can be implemented by
the 
.B X10ControllerUnit
class, and only specific differences applicable to the LynX-10 and Firecracker X-10 controllers are implemented in their respective classes.  If you are designing a new driver, have your controller object class inherit from the closest 
existing base class, or from
.B ControllerUnit
if it's completely unique.
.SS "Extending the Controller Class"
.LP
You need to extend the base 
.B ControllerUnit
class by adding the following methods as appropriate for your device.
In each case, check with the 
.B ControllerUnit
and
.B Channel
object class definitions (using 
.B pydoc
for example) and 
.I "do not deviate from the call signatures"
indicated there (as far as number or position of arguments, which are optional, etc.)
.LP
You MUST define device-specific versions of these methods (unless you
are inheriting from an intermediate class which does define them sufficiently):
.TP
.B all_channels_off()
Turns off all device channels.  In this case,
\*(lqoff\*(rq means to take the channels to the minimum allowed level
(which is either fully off, or the
.I warm
value set for that channel).
As with all of the following methods which
change channel state, this needs to update the channel state information
within the driver (usually a set of
.B Channel
objects) and then send the appropriate set of commands to the hardware
via the
.B _send_to_device()
method.
.TP
.B initialize_device()
Performs whatever setup is necessary to ensure that the controller is on-line,
with all channels off, and ready to begin receiving commands.
.TP
.B kill_all_channels()
Just like
.BR all_channels_off() ,
except that all channels are turned completely off, even if any have minimum
.I warm
values defined for them.
.TP
.BI kill_channel( id )
Kills a specific channel output, turning it complely off regardless of
any
.I warm
setting in effect.
.TP
.BI set_channel( id ", " level )
This should interact with the 
.B Channel
object associated with the given
.I id
for this controller, instructing it to set its value to
.IR level .
.TP
.BI setChannelOff( id )
Turns off (respecting any minimum
.I warm
level) the specified channel.
.TP
.BI setChannelOn( id )
Turns the specified channel fully on.
.\" .LP
.\" You SHOULD define extensions of these methods:
.LP
You MAY, but possibly won't need to, extend the following methods:
.TP
.RI \fBaddChannel(\fP id ", [" name "], [" load "], [" dimmer "], [" warm "], [" resolution "], ...\fB)\fP"
This method will be called by the Lumos application based on the
show configuration data, to assign active channels to your controller 
unit.  The default implementation of 
.B addChannel()
is a simple 
.B Channel
object factory which creates a new
.B Channel
instance and stores it in the controller's 
.B channels
attribute.  That's usually sufficient.
.RS
.LP
Note that this method will be passed the 
fields from the
.B show.conf
file as keyword arguments.  
Except for the
.IR load ,
.IR dimmer ,
and
.I warm
fields, which are appropriate native types, the fields will be strings
as written in the
.BR show.conf 
file.
.RE
.TP
.BR __init__( ... )
In most cases it should be unnecessary to override the class constructor
you inherit from
.BR ControllerUnit .
This will create the following attributes which your other methods may use:
.RS
.TP
.B powerSource
A reference to the 
.B PowerSource
object supplying power to this unit, as passed in the
.I power
argument to the constructor function.
.TP
.B resolution
Dimmer resolution as passed in the
.I resolution
constructor argument.  This will be whatever was passed
or the value 100 if nothing was passed when the new
controller object was created.  If your device has a different
resolution default, you can either make your own constructor
to offer that different default, or just handle it in your
.B addChannel()
method.
.B channels
The constructor also creates an empty dictionary to hold the 
channel objects for this controller, so your
.B addChannel()
method can simply add to this exsiting attribute.
.LP
Note that the constructor function for a given class will be passed the 
fields from the
.B show.conf
file as keyword arguments.  The 
.I type
field is not passed.  The
.I power
field value will be a
.B PowerSource
class object instance.  The rest will be strings as written in
.BR show.conf .
.LP
One addittional parameter passed to the constructor is
.IR network ,
which is a reference to the network driver object this particular device is 
connected to.
.RE
.TP
.BI _send_to_device( cmd )
Transmit the bytes in the
.I cmd
string to the hardware device itself.  This will pass 
.I cmd
to the associated 
.B Network
object, which in turn will transmit it to the device using the proper
communications device and protocol.
.TP
.B flush()
For devices which batch up bulk update command sequences, this method is
their cue to flush out all pending changes to the hardware.  The default
.B flush()
method does nothing (most known devices at the time Lumos was written do
not operate this way).
.LP
Since the drivers which ship with Lumos are available as source files,
it would be instructive to examine them as a pattern to follow when creating
new drivers.
.SS "Registering Your Device Driver"
.LP
The 
.RB \*(lq Controllers \*(rq
module provides a mapping from the controller device names presented to the
user (e.g., those usable in the
.B show.conf
file's description of controller types), and which actual device driver module
to use to actually control the hardware.
.LP
To add your new driver to the list, simply edit 
.B Controllers.py
and add two lines: an import statement to import the driver class,
and an entry in the
.B supported_controller_types
dictionary.  
For example, if we called our controllers \*(lqwhizzo\*(rq in all the
user-visible areas of Lumos, the first few lines of the
.B Controllers.py
file might look like this:
.RS
.na
.nf
\&.
\&.
\&.
.B "from WhizzoControllerUnit import WhizzoControllerUnit"
.B "supported_controller_types = {"
.B "\ \ \ 'lynx10':  LynX10ControllerUnit,"
.B "\ \ \ '48ssr':   SSR48ControllerUnit,"
.B "\ \ \ 'cm17a':   FirecrackerX10ControllerUnit,"
.B "\ \ \ 'whizzo':  WhizzoControllerUnit,"
.B }
\&.
\&.
\&.
.fi
.ad
.RE
.SH AUTHOR
.LP
Steve Willoughby, support@alchemy.com
.SH "SEE ALSO"
.BR Channel "(Lumos Module),"
.BR ControllerUnit "(Lumos Module),"
.BR lcheck (1),
.BR lumos (1),
.BR lumos-network (4),
.BR show.conf (5).
.SH BUGS
