#!/usr/bin/env python3
# vi:set ai sm nu ts=4 sw=4 expandtab:
#
# LUMOS POWER METER
#
# Lumos Light Orchestration System
# Copyright (c) 2005-2008, 2011, 2013, 2016 by Steven L. Willoughby, Aloha,
# Oregon, USA.  All Rights Reserved.  Licensed under the Open Software
# License version 3.0.
#
# This product is provided for educational, experimental or personal
# interest use, in accordance with the terms and conditions of the
# aforementioned license agreement, ON AN "AS IS" BASIS AND WITHOUT
# WARRANTY, EITHER EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION,
# THE WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A
# PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY OF THE ORIGINAL
# WORK IS WITH YOU.  (See the license agreement for full details, 
# including disclaimer of warranty and limitation of liability.)
#
# Under no curcumstances is this product intended to be used where the
# safety of any person, animal, or property depends upon, or is at
# risk of any kind from, the correct operation of this software or
# the hardware devices which it controls.
#
# USE THIS PRODUCT AT YOUR OWN RISK.
# 
# Estimate the power consumption of a sequence

import Lumos
from Lumos.Show import Show
from Lumos.Sequence import Sequence
from Lumos.Hexdump import hexdump
from optparse import OptionParser
import sys, csv
#@@REL@@sys.tracebacklimit=0

#========================================================================
# Command-line option processing
#========================================================================

parser = OptionParser(usage="%prog [-htv] [-c config] [-g file] [-P price] sequence-files...", version='@@RELEASE@@')
parser.add_option('-c', '--config',  metavar='FILE', help='Specify config file [%default]')
parser.add_option('-g', '--graph-data', metavar='FILE', help='Dump graphing data to CSV file')
parser.add_option('-P', '--price',   metavar='P',    type='float', help='Price per kWh for power')
parser.add_option('-t', '--throughput', action='store_true', help='Include data throughput analysis')
parser.add_option('-v', '--verbose', action='count', help='Enable more descriptive output')
parser.set_defaults(config='lumos.conf')
(options, files) = parser.parse_args()

#========================================================================
# Create show object from config file
#========================================================================

show = Show()
show.load_file(options.config.split(','), open_device=False)

#========================================================================
# Run each sequence, tallying up the power consumption at each time mark
#========================================================================

total_W_mS = 0  # watt-milliseconds

if options.verbose:
    print("Lumos Power Meter, version", parser.version)
    print("Show:", show.title)
    print("     ", show.description)
    print()

def trace_time_stamp(msec):
    "format and return milliseconds as h:m:s.ms"
    return "%02d:%02d:%02d.%03d" % (
        msec / 3600000,
        (msec / 60000) % 60,
        (msec / 1000) % 60,
        msec % 1000
    )

sequence = Sequence()
events = {}
peak_A = {}
peak_W = {}
peak_tp = {}
load_A = {}
load_W = {}
average_A = {}
average_W = {}
average_tp = {}
exceeds = {}
exceeds_tp = {}
over80 = {}
samples = 0
throughput = {}
sample_data_size = {}
next = 0

if options.graph_data:
    graph = csv.writer(open(options.graph_data, 'wb'))
    graph.writerow(['Seconds']+[s+' A' for s in sorted(show.all_power_sources)]+[s+' W' for s in sorted(show.all_power_sources)])

def D(format, *args):
    global options
    if options.verbose > 2:
        print("DEBUG: "+format.format(*args))

offset=0
for file in files:
    sequence.load_file(file, show.controllers)

    if options.verbose:
        print('Sequence "%s": duration %s; %d intervals' % (
            file, trace_time_stamp(sequence.total_time),
            len(sequence.intervals)
        ))

    previous_time=0
    #
    # The times from sequence.compile() are almost, but
    # not quite, chronological order. We need to read them
    # all in and then sort them before playing them back.
    #

    for current_time, method, arglist, priority in sequence.compile(keep_state = True):
        if current_time not in events:
            events[current_time] = []
        events[current_time].append((method, arglist))

    for current_time in sorted(events):
        #
        # execute whatever happens now
        #
        if options.throughput:
            for net_id, network in list(show.networks.items()):
                D('Starting data collection for {0} ({1})', net_id, network.description)
                network.divert_output()

        D('Simulating events at {}', trace_time_stamp(current_time))
        for action, arglist in events[current_time]:
            D('... action={0}({1})', action, arglist)
            action(*arglist)
        #
        # measure the power consumption
        #
        if load_W or sample_data_size:
            #
            # record the previous time slice's data, since we now
            # know how long it lasted.
            # load_x is a dictionary of {ps_id : (watts, amps)}
            #
            elapsed_mS = current_time - previous_time
            D("Recording slice {0}-{1} ({2}mS)", trace_time_stamp(previous_time), trace_time_stamp(current_time), elapsed_mS)

            total_W_mS += (
                    sum([load_W[ps_id] for ps_id in show.top_power_sources]) * elapsed_mS
            )
            D("... total W mS + {0} ({1}) = {2}",
                sum([load_W[ps_id] for ps_id in show.top_power_sources]) * elapsed_mS,
                [(ps_id, load_W[ps_id]) for ps_id in show.top_power_sources],
                total_W_mS
            )

            #
            # calculate peak and running averages for each power source's current
            # load at this point
            # 
            D('Calculating peak and running averages by power source:')
            next = samples + elapsed_mS
            for ps in list(show.all_power_sources.values()):
                D('...power source {0}: load {1} watts, {2} amps at {3} volts',
                    ps.id, load_W.get(ps.id, '--no--'), load_A.get(ps.id, '--no--'), ps.volts)

                if peak_A.setdefault(ps.id, 0) < load_A.get(ps.id, 0):
                    D('......new peak {0}->{1} amps', peak_A[ps.id], load_A.get(ps.id, 0))
                    peak_A[ps.id] = load_A.get(ps.id, 0)

                average_A[ps.id] = float( 
                        average_A.get(ps.id, 0) * samples + 
                        load_A.get(ps.id, 0) * elapsed_mS
                    ) / next

                if peak_W.setdefault(ps.id, 0) < load_W.get(ps.id, 0):
                    D('......new peak {0}->{1} watts', peak_W[ps.id], load_W.get(ps.id, 0))
                    peak_W[ps.id] = load_W.get(ps.id, 0)

                average_W[ps.id] = float( 
                        average_W.get(ps.id, 0) * samples + 
                        load_W.get(ps.id, 0) * elapsed_mS
                    ) / next
                D('......new average {0} amps, {1} watts', average_A[ps.id], average_W[ps.id])

                if load_A.get(ps.id, 0) >= ps.amps:
                    exceeds[ps.id] = exceeds.get(ps.id, 0) + elapsed_mS
                    D('......AT OR EXCEEDS MAX LOAD!')

                if load_A.get(ps.id, 0) > ps.amps * .8:
                    over80[ps.id] = over80.get(ps.id, 0) + elapsed_mS
                    D('......EXCEEDS 80% OF MAX LOAD!')

            if options.throughput:
                #
                # calculate peak and running averages for each network's throughput
                # 
                D('Calculating peak and running average throughput by network:')
                for net_id, network in list(show.networks.items()):
                    bits_sent = sample_data_size.get(net_id, 0) * (8 + 1 + network.stop)
                    bits_available = network.baudrate * (elapsed_mS / 1000.0)

                    D('...network {0}: {1} bit{2} sent (of {3} in {4} mS)',
                        net_id, bits_sent, 's' if bits_sent != 1 else '', bits_available, elapsed_mS)

                    throughput_utilization = float(bits_sent) / bits_available

                    if peak_tp.setdefault(net_id, 0) < throughput_utilization:
                        D('......new peak {0:%}->{1:%}', peak_tp[net_id], throughput_utilization)
                        peak_tp[net_id] = throughput_utilization

                    average_tp[net_id] = float( 
                            average_tp.get(net_id, 0) * samples + 
                            throughput_utilization * elapsed_mS
                        ) / next

                    D('......new average {0:%}', average_tp[net_id])

                    if bits_sent > bits_available:
                        exceeds_tp[net_id] = exceeds_tp.get(net_id, 0) + (bits_sent - bits_available)
                        D('......DID NOT HAVE TIME FOR {0} BIT{1} (total {2} now)!',
                            bits_sent - bits_available, '' if (bits_sent - bits_available)==1 else 'S',
                            exceeds_tp[net_id])
                        D('......  (in {0} mS at {1} baud, we can send {2} bit{4} but sent {3})',
                            elapsed_mS, network.baudrate, bits_available, bits_sent, '' if bits_available==1 else 's')

            samples = next

        #
        # gather next round of load data
        #
        load_A = {}
        load_W = {}
        for controller in list(show.controllers.values()):
            D("gathering next round of data from {0}", controller.id)
            for amps, source in list(controller.current_drain().values()):
                watts = float(amps) * source.volts
                D("... {0} A from {1}; at {2} V = {3} W", amps, source.id, source.volts, watts)

                while source:
                    if source.id not in load_A:
                        load_A[source.id] = 0
                    if source.id not in load_W:
                        load_W[source.id] = 0

                    load_W[source.id] += watts
                    load_A[source.id] += watts / source.volts
                    D('... {0} now at {1} W, {2} A ({3} V)', source.id, load_W[source.id], load_A[source.id], source.volts)
                    source = source.parent_source
        if options.throughput:
            sample_data_size = {}
            D("Calculating throughput for this event")
            for net_id, network in list(show.networks.items()):
                D("gathering next round of data from {0}", net_id)
                data_sent = network.end_divert_output()
                if options.verbose > 3:
                    hexdump(data_sent)
                sample_data_size[net_id] = len(data_sent)
                #D("...{0} byte{1}, total {2}", len(data_sent), '' if len(data_sent) == 1 else 's')

        if options.graph_data:
            graph.writerow([(current_time+offset)/1000.0] + [load_A.get(i,0) for i in sorted(show.all_power_sources)] + [load_W.get(i, 0) for i in sorted(show.all_power_sources)])
        #
        # we now have a total of the load starting at this time
        # for all the power sources in the loads dict.  We'll have
        # to wait for the next event to know how long that lasts,
        # and the update_load_totals() function will tabulate that
        # then.
        #
        previous_time = current_time
    offset += previous_time

if load_A:
    warned = False
    for source_id in sorted(load_A):
        value = load_A[source_id]
        if value:
            if not warned:
                print()
                print("** NOTE **")
                print("The following circuit(s) had power draining at the end of the show.")
                print("If they remain on after the show, they will consume additional")
                print("power beyond what this report is showing.")
                print("This final power level was the end-state at the last instant of the")
                print("sequence, so is not figured into the calculations reported.")
                print()
                warned = True
            print("{0:6.2f} amps on {1}".format(value, source_id))

#
# Report out
# 
total_kW_h = total_W_mS / 3600000000.0
print("Total Runtime:      {0} ({1:,d} mS)".format(trace_time_stamp(samples), samples))
print("Total Power Used:   {0:.6f} kWh".format(total_kW_h))

if options.price:
    print("Total Energy Cost: ${0:.4f} (~${0:.2f}) @ ${1:.4f}/kWh".format(total_kW_h * options.price, options.price))

max_ps_id = max([12]+[len(ps_id) for ps_id in peak_A])
print(("{0:<"+str(max_ps_id)+"} PEAK (A)   AVERAGE (A)  PEAK (W)  AVERAGE (W)").format('POWER SOURCE'))
#      xxxxxx[15]xxxxx 99999.99   99999.99999  99999.99  99999.99999
for ps_id in sorted(peak_A):
    print(("{0:<"+str(max_ps_id)+"} {1:8.2f}   {2:11.5f}  {3:8.2f}  {4:11.5f}").format(
            ps_id, peak_A[ps_id], average_A[ps_id],
            peak_W[ps_id], average_W[ps_id]
    ))

for ps_id in sorted(over80):
    print("*** WARNING *** {0} OVER 80% LOAD FOR TOTAL OF {1}".format(ps_id, trace_time_stamp(over80[ps_id])))
for ps_id in sorted(exceeds):
    print("*** WARNING *** {0} AT OR OVER 100% LOAD FOR TOTAL OF {1}".format(ps_id, trace_time_stamp(exceeds[ps_id])))

if options.throughput:
    max_net_id = max([7]+[len(net_id) for net_id in peak_tp])
    print(" "*max_net_id + " THROUGHPUT (BPS SENT VS. BPS AVAILABLE PER EVENT)")
    print(("{0:<"+str(max_net_id)+"} PEAK    AVERAGE").format('NETWORK'))
    #      xxxxxx[15]xxxxx 999.99% 999.99%
    for net_id in sorted(peak_tp):
        print(("{0:<"+str(max_net_id)+"} {1:7.2%} {2:7.2%}").format(
            net_id, peak_tp[net_id], average_tp[net_id]
        ))
    for net_id in sorted(exceeds_tp):
        print("*** WARNING *** {0} DID NOT HAVE TIME FOR {1} BIT{2} AT CONFIGURED BAUD RATE!".format(
            net_id, exceeds_tp[net_id], '' if exceeds_tp[net_id]==1 else 'S'))
